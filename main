# board in grid coordinates
# 0  1  2  ...
# 1
# 2
# ...
# board in chess coordinates
# a0 b  c  ...
# 1
# 2
# ...

# numerical vs grid cordinates vs chess cordinates
# (for pawn x,y) 80, 160 -> 1, 2 -> b2


import sys
from PyQt5.QtWidgets import QApplication, QRadioButton, QGraphicsSceneMouseEvent, QWidget, QMainWindow, QPushButton, QLabel,  QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsItem, QLineEdit, QTextEdit
from PyQt5.QtSvg import QGraphicsSvgItem
from PyQt5.QtGui import QBrush, QColor, QFont, QKeyEvent, QTextOption
from PyQt5.QtCore import Qt, QThread
import numpy as np
import sqlite3
import sys
import xml.etree.ElementTree as ET
import json


import threading
import time   


class ClockThread(QThread):
    def __init__(self, timeAmount, parent=None):
        super().__init__(parent)
        self.timeAmount = timeAmount
        # self.model = model
        # self.mainWindow = mainWindow
        self.TimeAmount = 0

    def run(self):
        while True:
            time.sleep(1)
            self.TimeAmount -= 1
            # self.mainWindow.updateLabel(f"{self.TimeAmount // 60}:{self.TimeAmount % 60}")
            if self.TimeAmount == 0:
                print("Time is up")
    
    def set(self, timeAmount):
        self.TimeAmount = timeAmount

class model():
    def __init__(self, presenter):
        super(model, self).__init__()
        self.presenter = presenter
        # create empty 2d array with 8x8 dimensions
        self.currentBoardState = [[0 for _ in range(8)] for _ in range(8)]
        

        self.initCurrentBoardState()

    def canMove(self, name, prevX, prevY, x, y):
        # all cordinates here are in grid cordinates
        # checking only if the move is possible then return True
        
        if self.currentBoardState[y][x] != 'empty':
            return False

        return True
    
    def updateBoardState(self, name, prevX, prevY, x, y):
        # all cordinates here are in grid cordinates
        # update the board state after the move
        print(f"Moving {name} from {prevX}, {prevY} to {x}, {y}")
        self.currentBoardState[y][x] = name
        self.currentBoardState[prevY][prevX] = 'empty'
    
    def initCurrentBoardState(self):
        for i in range(8):
            self.currentBoardState[1][i] = 'whitepawn'
            self.currentBoardState[6][i] = 'blackpawn'
        self.currentBoardState[0][0] = 'whiterook'
        self.currentBoardState[0][7] = 'whiterook'
        self.currentBoardState[7][0] = 'blackrook'
        self.currentBoardState[7][7] = 'blackrook'
        self.currentBoardState[0][1] = 'whiteknight'
        self.currentBoardState[0][6] = 'whiteknight'
        self.currentBoardState[7][1] = 'blackknight'
        self.currentBoardState[7][6] = 'blackknight'
        self.currentBoardState[0][2] = 'whitebishop'
        self.currentBoardState[0][5] = 'whitebishop'
        self.currentBoardState[7][2] = 'blackbishop'
        self.currentBoardState[7][5] = 'blackbishop'
        self.currentBoardState[0][3] = 'whitequeen'
        self.currentBoardState[7][3] = 'blackqueen'
        self.currentBoardState[0][4] = 'whiteking'
        self.currentBoardState[7][4] = 'blackking'

        for i in range(8):
            for j in range(8):
                if self.currentBoardState[i][j] == 0:
                    self.currentBoardState[i][j] = 'empty'

class MainWindow(QMainWindow):
    def __init__(self, presenter):
        super(MainWindow, self).__init__()
        self.presenter = presenter

        # creating scene and view for chess board
        self.scene = QGraphicsScene(self)
        self.scene.setSceneRect(0, 0, 640, 640)
        self.view = QGraphicsView(self)
        self.view.setGeometry(0, 0, 642, 642)
        self.view.setScene(self.scene)

        self.initUI()
        self.addPieces()


    def initUI(self):
        self.setWindowTitle('Chess Game by Maksymilian Anzulewicz Beta 0.2')
        self.setFixedSize(1128, 720)

        self.drawBoard()

        # creates buttons, text fields and labels
        self.createButtonSTART(700, 20, 'START')
        self.createButton2(700, 50, 'Przycisk 2')
        self.createButtonTime1(700, 120, 'Time 10 min')
        self.createButtonTime2(700, 150, 'Time 1 min')
        self.createlabel(710, 80, 110, 40, "00:00")
        self.createTextField(700, 200, 180, 50)
        self.createTextField2(700, 300, 180, 400)
        self.createRadioButtons(820, 20, 180, 50)
        self.createLabelsForRadioButtons(840, 20, 180, 50, "AI bot", "Player same PC", "Multiplayer")
        self.createTextBoxesForIPandPort(820, 120, 100, 20)
        self.createLabelsForIPandPort(930, 120, 100, 20, "IP", "Port")

        self.show()

    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)
    def updateMoveLog(self, move_notation):
        # Method to update the QTextEdit or QLineEdit with the move notation
        current_text = self.text_field2.toPlainText()
        new_text = f"{current_text}\n{move_notation}"  # Append the new move
        self.text_field2.setText(new_text)  # For QLineEdit
        # If you're using QTextEdit, you might prefer: self.text_field2.append(move_notation)
    def updateLabel(self, text):
        self.label.setText(text)
    def updateTextField2(self, text):
        # if self.insideTimer == 0:
        #     return
        # else:
        #     text = self.model.returnFigurePositionToChessCordinates(self.model.last_moved_piece)
        #     self.text_field2.setText(text)
        #     self.insideTimer += 1
        return
    def readTextField(self):
        text = self.text_field.text()
        return text
    def readIP(self):
        text = self.textBoxIP.text()
        self.textBoxIP.clear()
        return text
    def readPort(self):
        text = self.textBoxPort.text()
        self.textBoxPort.clear()
        return text
    def readRadioButton(self):
        playerchoice = ""
        if self.radioButtonAIbot.isChecked():
            playerchoice = "AI bot"
        elif self.radiobuttonPlayerSamePC.isChecked():
            playerchoice = "Player same PC"
        elif self.radiobuttonMultiplayer.isChecked():
            playerchoice = "Multiplayer"

        return playerchoice

    def createButtonSTART(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onButtonClickSTART)
        button.resize(100, 30)
    def createButton2(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onButtonClick2)
        button.resize(100, 30)
    def createButtonTime1(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onTimeButtonClick1)
        button.resize(100, 30)
    def createButtonTime2(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onTimeButtonClick2)
        button.resize(100, 30)
    def createWindowContainer(self, x, y, width, height, text):
        self.windowContainer = QWidget(self)
        self.windowContainer.setGeometry(x, y, width, height)
        self.windowContainer.setWindowTitle(text)
    def createlabel(self, x, y, width, height, text):
        self.label = QLabel(self)
        self.label.setText(text)
        self.label.move(x, y) 
        self.label.resize(width, height)
        self.label.setFont(QFont("Arial", 20))
    def createTextField(self, x, y, width, height):
        self.text_field = QLineEdit(self)
        self.text_field.move(x, y)
        self.text_field.resize(width, height)
    def createTextField2(self, x, y, width, height):
        self.text_field2 = QTextEdit(self)
        self.text_field2.move(x, y)
        self.text_field2.resize(width, height)
        self.text_field2.setReadOnly(True)
        self.text_field2.setAlignment(Qt.AlignTop)
        self.text_field2.setWordWrapMode(QTextOption.WordWrap)
    def createRadioButtons(self, x, y, width, height):
        self.radioButtonAIbot = QRadioButton(self)
        self.radioButtonAIbot.move(x, y)
        self.radioButtonAIbot.resize(width, height)

        self.radiobuttonPlayerSamePC = QRadioButton(self)
        self.radiobuttonPlayerSamePC.move(x, y + 30)
        self.radiobuttonPlayerSamePC.resize(width, height)

        self.radiobuttonMultiplayer = QRadioButton(self)
        self.radiobuttonMultiplayer.move(x, y + 60)
        self.radiobuttonMultiplayer.resize(width, height)
    def createLabelsForRadioButtons(self, x, y, width, height, text1, text2, text3):
        self.labelAIbot = QLabel(self)
        self.labelAIbot.setText(text1)
        self.labelAIbot.move(x, y)
        self.labelAIbot.resize(width, height)

        self.labelPlayerSamePC = QLabel(self)
        self.labelPlayerSamePC.setText(text2)
        self.labelPlayerSamePC.move(x, y + 30)
        self.labelPlayerSamePC.resize(width, height)

        self.labelMultiplayer = QLabel(self)
        self.labelMultiplayer.setText(text3)
        self.labelMultiplayer.move(x, y + 60)
        self.labelMultiplayer.resize(width, height)
    def createTextBoxesForIPandPort(self, x, y, width, height):
        self.textBoxIP = QLineEdit(self)
        self.textBoxIP.move(x, y)
        self.textBoxIP.resize(width, height)

        self.textBoxPort = QLineEdit(self)
        self.textBoxPort.move(x, y + 25)
        self.textBoxPort.resize(width, height)
    def createLabelsForIPandPort(self, x, y, width, height, text1, text2):
        self.labelIP = QLabel(self)
        self.labelIP.setText(text1)
        self.labelIP.move(x, y)
        self.labelIP.resize(width, height)

        self.labelPort = QLabel(self)
        self.labelPort.setText(text2)
        self.labelPort.move(x, y + 25)
        self.labelPort.resize(width, height)

    def onTimeButtonClick1(self):
        self.Clock.set(600)
        self.updateLabel("10:00")
    def onTimeButtonClick2(self):
        self.Clock.set(60)
        self.updateLabel("01:00")
    def onButtonClickSTART(self):
        # self.model.gameStarted = True
        # self.Clock.start()
        # print("Game has started")
        return
    def onButtonClick2(self):
        print("Kliknięto przycisk")

    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)

    def addPieces(self):
        for i in range(8):
            self.scene.addItem(ChessPiece("pieces/white/wpawn.svg", 80 * i, 80, 'white', 'pawn', self))
            self.scene.addItem(ChessPiece("pieces/black/bpawn.svg", 80 * i, 480, 'black', 'pawn', self))

        self.scene.addItem(ChessPiece("pieces/white/wrook.svg", 0, 0, 'white', 'rook', self))
        self.scene.addItem(ChessPiece("pieces/white/wrook.svg", 560, 0, 'white', 'rook', self))
        self.scene.addItem(ChessPiece("pieces/black/brook.svg", 0, 560, 'black', 'rook', self))
        self.scene.addItem(ChessPiece("pieces/black/brook.svg", 560, 560, 'black', 'rook', self))
        self.scene.addItem(ChessPiece("pieces/white/wknight.svg", 80, 0, 'white', 'knight', self))
        self.scene.addItem(ChessPiece("pieces/white/wknight.svg", 480, 0, 'white', 'knight', self))
        self.scene.addItem(ChessPiece("pieces/black/bknight.svg", 80, 560, 'black', 'knight', self))
        self.scene.addItem(ChessPiece("pieces/black/bknight.svg", 480, 560, 'black', 'knight', self))
        self.scene.addItem(ChessPiece("pieces/white/wbishop.svg", 160, 0, 'white', 'bishop', self))
        self.scene.addItem(ChessPiece("pieces/white/wbishop.svg", 400, 0, 'white', 'bishop', self))
        self.scene.addItem(ChessPiece("pieces/black/bbishop.svg", 160, 560, 'black', 'bishop', self))
        self.scene.addItem(ChessPiece("pieces/black/bbishop.svg", 400, 560, 'black', 'bishop', self))
        self.scene.addItem(ChessPiece("pieces/white/wqueen.svg", 240, 0, 'white', 'queen', self))
        self.scene.addItem(ChessPiece("pieces/black/bqueen.svg", 240, 560, 'black', 'queen', self))
        self.scene.addItem(ChessPiece("pieces/white/wking.svg", 320, 0, 'white', 'king', self))
        self.scene.addItem(ChessPiece("pieces/black/bking.svg", 320, 560, 'black', 'king', self))

    def keyPressEvent(self, event: QKeyEvent) -> None:
        if event.key() == Qt.Key_Escape:
            self.close()
        elif event.key() == Qt.Key_A:
            radiobutton = self.readRadioButton()
            ip = self.readIP()
            port = self.readPort()
            print(f"Radiobutton: {radiobutton}, IP: {ip}, Port: {port}")

            self.presenter.saveMovesHistoryToXML(self.presenter.moves_history)
            self.presenter.saveGameInfoToFile(radiobutton, ip, port)
        elif event.key() == Qt.Key_B:
            game_mode, address, port = self.presenter.loadGameInfoFromFile()
            print(f"Game mode: {game_mode}, Address: {address}, Port: {port}")
        super().keyPressEvent(event)

class Presenter():
    def __init__(self, clk):

        self.clk = clk
        self.model = model(self)
        self.win = MainWindow(self)

        self.moves_history = []


        self.createSQLbaseForMovesHistory()

    def convertNumericalToGridCordinates(self, x, y):
        return x / 80, y / 80
    
    def convertGridToChessCordinates(self, x, y, name):
        if name == 'rook':
            charachter = 'R'
        elif name == 'knight':
            charachter = 'N'
        elif name == 'bishop':
            charachter = 'B'
        elif name == 'queen':
            charachter = 'Q'
        elif name == 'king':
            charachter = 'K'
        elif name == 'pawn':
            charachter = ''
        else:
            charachter = ''
        
        print(f"{charachter}{chr(97 + x)}{y + 1}")

        return f"{charachter}{chr(97 + x)}{y + 1}"

    def updateMovesHistory(self, move_notation):
        self.moves_history.append(move_notation)
        self.win.updateMoveLog(move_notation)

    def createSQLbaseForMovesHistory(self):
        self.deleteExistingDataBaseDEBBUG()

        # Establish a connection to the database
        conn = sqlite3.connect('chess.db')

        # Create a cursor object to execute SQL queries
        c = conn.cursor()

        # Create the 'moves_history' table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS moves_history
                    (move TEXT)''')

        # Commit changes to the database
        conn.commit()

        # **DO NOT CLOSE THE CONNECTION HERE**

        # Use the connection and cursor as needed for subsequent operations
        # ...

        # Close the connection when done with all database operations
        conn.close()

    def updateSQLbase(self, move_notation):
        # Establish a connection to the database
        conn = sqlite3.connect('chess.db')

        # Create a cursor object to execute SQL queries
        c = conn.cursor()

        # Insert the move notation into the 'moves_history' table
        c.execute('INSERT INTO moves_history VALUES (?)', (move_notation,))

        # Commit changes to the database
        conn.commit()

        # Close the connection when done with all database operations
        conn.close()

    def deleteExistingDataBaseDEBBUG(self):
        conn = sqlite3.connect('chess.db')
        c = conn.cursor()
        c.execute('DROP TABLE moves_history')
        conn.commit()
        conn.close()
 
    def saveMovesHistoryToXML(self, moves_history):
        # Create the root element for the XML document
        root = ET.Element("MovesHistory")

        # Iterate through each move in the history and create an XML element for each
        for move in moves_history:
            move_element = ET.Element("Move")
            move_element.text = move
            root.append(move_element)

        # Create an XML file object
        xml_file = open("moves_history.xml", "w")

        # Write the XML tree to the file
        tree = ET.tostring(root, encoding="utf-8")
        xml_file.write(tree.decode("utf-8"))

        # Close the file
        xml_file.close()

    def saveGameInfoToFile(self, game_mode, address, port, filename="game_info.json"):
        # Create a dictionary to store the game information
        game_info = {
            "game_mode": game_mode,
            "address": address,
            "port": port
        }

        # Open the JSON file in write mode ("w")
        with open(filename, "w") as json_file:
            # Convert the dictionary to JSON format and write it to the file
            json.dump(game_info, json_file, indent=4)
    def loadGameInfoFromFile(self, filename="game_info.json"):
        # Attempt to open the JSON file in read mode ("r")
        try:
            with open(filename, "r") as json_file:
                # Load the JSON data from the file
                game_info = json.load(json_file)

            # Extract and return the game mode, address, and port
            game_mode = game_info["game_mode"]
            address = game_info["address"]
            port = game_info["port"]

            return game_mode, address, port

        # Handle exceptions if the file cannot be opened or read
        except (FileNotFoundError, json.JSONDecodeError):
            print(f"Error loading game info from file: {filename}")
            return None, None, None
        

class ChessPiece(QGraphicsSvgItem):
    def __init__(self, svg_path, x, y, color, name, win):
        super().__init__(svg_path)
        self.win = win
        self.Name = name
        self.defaultScale = 1.8
        self.color = color
        self.oposite_color = self.color == 'white' and 'black' or 'white'
        self.hasMoved = False
        self.PrevX = x
        self.PrevY = y

        self.setPos(x, y)
        self.setScale(self.defaultScale)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemIsSelectable)

    def pos(self):
        return self.x, self.y
    
    def PreviousPosition(self):
        return self.PrevX, self.PrevY

    def mouseReleaseEvent(self, event: QGraphicsSceneMouseEvent) -> None:
        self.setScale(self.defaultScale)

        newx, newy = self.convertNumericalToGridCordinates(self.x(), self.y())
        PrevX, PrevY = self.convertNumericalToGridCordinates(self.PrevX, self.PrevY)
        if self.win.presenter.model.canMove(self.Name, self.PrevX, self.PrevY, newx, newy) and newx >= 0 and newx < 8 and newy >= 0 and newy < 8:
            self.win.presenter.model.updateBoardState(self.Name, PrevX, PrevY, newx, newy)
            self.win.presenter.updateSQLbase(self.win.presenter.convertGridToChessCordinates(newx, newy, self.Name))
            self.win.presenter.updateMovesHistory(self.win.presenter.convertGridToChessCordinates(newx, newy, self.Name))
            self.setPos(newx * 80, newy * 80)
        else:
            self.setPos(self.PrevX, self.PrevY)
        super().mouseReleaseEvent(event)

    def mousePressEvent(self, event: QGraphicsSceneMouseEvent) -> None:
        self.PrevX = self.x()
        self.PrevY = self.y()
        self.setScale(self.defaultScale + 0.2)
        super().mousePressEvent(event)

    def convertNumericalToGridCordinates(self, x, y):
        return round(x / 80), round(y / 80)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    clk = ClockThread(0)
    Presenter = Presenter(clk)

    sys.exit(app.exec_())