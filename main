# TO DO
# Roszada
# zbieranie ruchów
# Zegar
# Warunek wygranej NO w miare git ale dalej do poprienia
# poruszanie figur notacją szachową

import sys
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QVBoxLayout, QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsItem
from PyQt5.QtSvg import QGraphicsSvgItem
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtCore import Qt, QPointF

import threading
import time   

class ClockThread(threading.Thread):
    def __init__(self, chessboard, TimeAmount):
        threading.Thread.__init__(self)
        self.chessboard = chessboard
        self.TimeAmount = TimeAmount

    def run(self, TimeAmount):
        while True:
            time.sleep(1)
            self.TimeAmount -= 1
            if self.TimeAmount == 0:
                self.chessboard.switchTurnsAndAddOneToTurnTimer()
                self.TimeAmount = 60

class ChessBoard(QGraphicsView):
    def __init__(self, *args, **kwargs):
        super(ChessBoard, self).__init__(*args, **kwargs)
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.drawBoard()
        self.setFixedSize(900, 640)
        self.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        self.addPieces()
        self.current_turn = 'white'  # White starts the game
        self.current_board_state = [[0 for _ in range(8)] for _ in range(8)]
        self.turnTimer = 0
        self.setStartingboardState()
        self.isCheck = False
        self.witchKingisCheck = None


        # Opcjonalnie, możesz tutaj ustawić rozmiar widoku, aby pasował do rozmiaru sceny
        self.scene.setSceneRect(0, 0, 640, 640)  # Zakładając, że rozmiar planszy to 640x640
        self.setFixedSize(900 + 2, 640 + 2)  # +2 dla marginesu; dostosuj według potrzeb

    def oposite_color(self, color):
        return 'white' if color == 'black' else 'black'
    

    def can_castle(self, king, rook):
        # Check if the king and rook have not moved
        if king.has_moved or rook.has_moved:
            return False

        # Mechanic that Check if the squares between the king and rook are empty
        for i in range(1, 3):
            if self.current_board_state[king.original_grid_y][king.original_grid_x + i] != "Empty":
                return False

        # Mechanic that Check if the king is in check
        

        # Check if the squares the king crosses are attacked


        return True

    def get_king(self, color):
        for piece in self.get_all_pieces(color):
            if piece.isKing == True and piece.color == color:
                # print(f"King {piece.color} {piece.__class__.__name__} is in {piece.pos()}")
                return piece

    def get_all_pieces(self, color):
        pieces = []
        for item in self.scene.items():
            if isinstance(item, ChessPiece) and item.color == color:
                pieces.append(item)
        
        # print(f"Number of {color} pieces: {len(pieces)}")
        return pieces
    

    def friendly_color(self, color):
        return 'black' if color == 'black' else 'white'

    def can_move(self, piece, position):
        # Check if the piece can move to the position
        piece.targetting = True
        piece.target_Position_x = position.x()
        piece.target_Position_y = position.y()
        piece.validate_move(self)
        #print if the move is valid for figure
        # print(f"figure {piece.color} {piece.__class__.__name__} has {piece.valid_move} move to {position.x(), position.y()}")
        #print(f"figure {piece.color} {piece.__class__.__name__} is in {piece.pos()} and wants to move to {position.x(), position.y()}")
        if piece.valid_move:
            # print(f"figure {piece.color} {piece.__class__.__name__} can move to {position.x(), position.y()}")
            piece.valid_move = False
            piece.targetting = False
            return True
        
        piece.targetting = False
        return False

    def is_check(self, color):
        # Get the position of the king
        king_position = self.get_king(self.oposite_color(color))
        # print oposite color
        # print(f"Oposite color: {self.oposite_color(color)}")

        # After move, code checks all friendly pieces if they can move to the enemy king position
        for piece in self.get_all_pieces(color):
            # print(f" {piece.pieceName}")
            if self.can_move(piece, king_position.pos()):
                print(f"Check by {piece.color} {piece.__class__.__name__}")
                print (f"King {king_position.color} {king_position.__class__.__name__} is in {king_position.pos()}")
                print(f"figure position is {piece.pos()}")
                # print king position that is in check
                #print(f"King {king_position.color} {king_position.__class__.__name__} is in {king_position.pos()}")   
                return True

        return False

    # Method to switch turns
    def switchTurnsAndAddOneToTurnTimer(self):
        self.current_turn = 'black' if self.current_turn == 'white' else 'white'

        #print(f"Turn: {self.current_turn}")
        # Add one to the turn timer
        self.turnTimer += 1

        # # Check if there is a check
        # if self.is_check(self.current_turn):
        #     print(f"Check by {self.current_turn}")



    def is_checkmate(self, color):
        # Check if the king is in check
        if not self.is_check(color):
            return False

        # Check if the king can move to a safe position
        king = self.get_king(color)
        for i in range(8):
            for j in range(8):
                if self.can_move(king, QPointF(i * 80, j * 80)):
                    return False

        # Check if any piece can capture the attacking piece
        for piece in self.get_all_pieces(color):
            for i in range(8):
                for j in range(8):
                    if self.can_move(piece, QPointF(i * 80, j * 80)):
                        return False

        return True

    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)

    def addPieces(self):
        # Black pieces
        self.addPiece(Rook("pieces/black/brook.svg", 0, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 1, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 2, 0, 'black',self))
        self.addPiece(Queen("pieces/black/bqueen.svg", 3, 0, 'black',self))
        self.addPiece(King("pieces/black/bking.svg", 4, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 5, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 6, 0, 'black',self))
        self.addPiece(Rook("pieces/black/brook.svg", 7, 0, 'black',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/black/bpawn.svg", i, 1, 'black', self))
        
        # White pieces
        self.addPiece(Rook("pieces/white/wrook.svg", 0, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 1, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 2, 7, 'white',self))
        self.addPiece(Queen("pieces/white/wqueen.svg", 3, 7, 'white',self))
        self.addPiece(King("pieces/white/wking.svg", 4, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 5, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 6, 7, 'white',self))
        self.addPiece(Rook("pieces/white/wrook.svg", 7, 7, 'white',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/white/wpawn.svg", i, 6, 'white', self))


    def addPiece(self, piece):
        self.scene.addItem(piece)

    def setStartingboardState(self):

        # Empty spaces
        for i in range(2, 6):
            for j in range(8):
                self.current_board_state[i][j] = "Empty"

        for i in range(8):
            for j in range(2):
                self.current_board_state[j][i] = "black_piece"

        for i in range(8):
            for j in range(6, 8):
                self.current_board_state[j][i] = "white_piece"
                
        self.current_board_state[7][4] = "white_king"     
        self.current_board_state[0][4] = "black_king"


    def getBoardState(self):
        return self.current_board_state

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Przykład aplikacji')
        self.setFixedSize(900, 640)  # Ustawia pozycję i rozmiar głównego okna

        # Tworzy i umieszcza szachownicę
        self.chessBoard = ChessBoard(self)
        self.chessBoard.setGeometry(0, 0, 640, 640)  # Ustawia pozycję i rozmiar szachownicy

        # Tworzy i umieszcza przyciski
        self.createButton(800, 20, 'Przycisk 1')
        self.createButton(800, 50, 'Przycisk 2')

    def createButton(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onButtonClick)

    def onButtonClick(self):
        print("Kliknięto przycisk")
    
class ChessPiece(QGraphicsSvgItem):
    def __init__(self, image_path, x, y, color, chessboard):
        super(ChessPiece, self).__init__(image_path)
        self.setPos(x * 80, y * 80)
        self.default_scale = 1.8
        self.setScale(self.default_scale)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemIsSelectable)
        self.color = color
        self.chessboard = chessboard
        self.isKing = False
        self.valid_move = False
        self.direction = 1 if self.color == 'black' else -1
        self.oposite_color = 'white' if self.color == 'black' else 'black'
        self.original_grid_x = x
        self.original_grid_y = y
        self.target_Position_x = 0
        self.target_Position_y = 0
        self.targetting = False # i know its so stupid but i dont know how to do it better
        self.pieceName = self.__class__.__name__

    def mousePressEvent(self, event):
        super(ChessPiece, self).mousePressEvent(event)

        # Store the current grid position when the mouse is pressed
        self.original_grid_x = int(self.x() / 80)
        self.original_grid_y = int(self.y() / 80)

    def validate_move(self, chessboard):

        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        # Check bounds
        if not (0 <= new_grid_x <= 7 and 0 <= new_grid_y <= 7):
            self.valid_move = False
            return

        # # checing condition if there is figure on the new position [exlcuding the case of pawn]
        # if self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":

        #     # cant move if there is friendly piece on the new position
        #     if self.color == 'black':
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_piece", "black_king"]:
        #             self.valid_move = False
        #             return
        #     elif self.color == 'white':
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["white_piece", "white_king"]:
        #             self.valid_move = False
        #             return

        #     if self.targetting == False:
        #         # cannot move if there is a king piece in the new position
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_king" or self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_king":
        #             self.valid_move = False
        #             return
        #     elif self.targetting == True:
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_king" or self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_king":
        #             self.valid_move = True

        if self.targetting == False:
            # if the piece is not the color of the current turn, it cannot move
            if self.color != self.chessboard.current_turn:
                self.valid_move = False
                return
        elif self.targetting == True:
            if self.color != self.chessboard.current_turn:
                self.valid_move = True
        
        if self.targetting == False:
            if self.valid_move:
                self.first_move = False


        # correct way 
        if self.targetting == False:
        # if there is a friendly figure on the destination square, the queen cannot move to this position
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] in [self.color + "_piece", self.color + "_king", self.oposite_color + "_king"]:
                self.valid_move = False
                return
        elif self.targetting == True:
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True



        # print("tu patrze jaka figura ma targetting position")
        # print(self.target_Position_x, self.target_Position_y)
        self.valid_move = True

    def get_current_position(self):
        return self.x(), self.y()

    def cupture_piece(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        # remove piece that is being taken by player
        for item in self.scene().items():
            if isinstance(item, ChessPiece) and item.x() == new_x and item.y() == new_y:
                self.scene().removeItem(item)
                break

    def return_to_original_position(self):
        # print("Return to original position")
        self.setPos(self.original_grid_x * 80, self.original_grid_y * 80)

    def move_piece(self):

        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        self.validate_move(self.chessboard)

        if self.targetting == False:
            # updating the board state and moving the piece if the move is valid
            if self.valid_move == True:
                self.cupture_piece()
                self.setPos(new_x, new_y)
                self.updateBoardStatus()
                self.chessboard.switchTurnsAndAddOneToTurnTimer()
                self.first_move = False
                self.valid_move = False
                # print(f"figure {self.color} {self.__class__.__name__} moved to {self.calculate_position()}")
            elif self.valid_move == False:
                self.return_to_original_position()


    def mouseReleaseEvent(self, event):
        super(ChessPiece, self).mouseReleaseEvent(event)


        self.setScale(self.default_scale)

        self.move_piece()

        # Check if there is a check
        if self.chessboard.is_check(self.color):
            print(f"Check by {self.color}")
        if self.chessboard.is_checkmate(self.oposite_color):
            print(f"Check by {self.oposite_color}")

        #self.printCurrentBoardStateInTerminal()

        # # check if there is a check
        # if self.chessboard.is_check(self.color):
        #     print(f"Check by {self.color}")

    def updateBoardStatus(self):

        # prevoius move of the piece
        prev_x = round(self.original_grid_x * 80)
        prev_y = round(self.original_grid_y * 80)

        prev_grid_x = int(prev_x / 80)
        prev_grid_y = int(prev_y / 80)

        self.chessboard.current_board_state[prev_grid_y][prev_grid_x] = "Empty"

        # current move of the piece
        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)

        if self.color == 'black':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_piece"
        elif self.color == 'white':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_piece"

        # self.printCurrentBoardStateInTerminal()

    def calculate_position(self):

        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)


        return new_x, new_y, new_grid_x, new_grid_y
    
    def getStartingGridPosition(self):
        return self.original_grid_x, self.original_grid_y

    # only for debugging
    def printCurrentBoardStateInTerminal(self):
        for row in self.chessboard.current_board_state:
            print(row)
        print('\n')

    def getPreviousGridPosition(self):
        return self.original_grid_x, self.original_grid_y   

class Pawn(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Pawn, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def validate_move(self, chessboard):
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()
        # if self.targetting == True:
        #     print(original_grid_x, original_grid_y, new_grid_x, new_grid_y)

        # if self.first_move == False:
        #     # pawn can move one square forward
        #     if self.color == "white" and new_grid_y == original_grid_y - 1 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
        #         self.valid_move = True
        #     else:
        #         self.valid_move = False
        #         return
        #     if self.color == "black" and new_grid_y == original_grid_y + 1 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
        #         self.valid_move = True
        #     else:
        #         self.valid_move = False
        #         return
        # elif self.first_move == True:
        #     # pawn can move two squares forward on its first move
        #     if self.first_move and self.color == "white" and new_grid_y == original_grid_y - 2 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y + 1][new_grid_x] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
        #         self.valid_move = True
        #     else:
        #         self.valid_move = False
        #         return
        #     if self.first_move and self.color == "black" and new_grid_y == original_grid_y + 2 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y - 1][new_grid_x] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
        #         self.valid_move = True
        #     else:
        #         self.valid_move = False
        #         return

        # pawn movement mechanic
        if self.first_move == True:
            if abs(new_grid_y - original_grid_y) > 2 and abs(new_grid_y - original_grid_y) > 2:
                self.valid_move = False
                return
        elif self.first_move == False:
            if abs(new_grid_y - original_grid_y) > 1 and abs(new_grid_y - original_grid_y) > 1:
                self.valid_move = False
                return
        
        # pawn can only move diagonally when capturing an opponent's piece
        # if abs(new_grid_x - original_grid_x) == 1 and abs(new_grid_y - original_grid_y) == 1:
        #     if self.targetting == False:
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_piece":
        #             self.valid_move = True
        #     elif self.targetting == True:
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] in [self.oposite_color + "_piece", self.oposite_color + "_king"]:
        #             self.valid_move = True
        
        # pawn can only move diagonally when capturing an opponent's piece
        if self.targetting == False:
            if self.color == "white" and new_grid_y == original_grid_y - 1 and (new_grid_x == original_grid_x + 1 or new_grid_x == original_grid_x - 1) and self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_piece":
                self.valid_move = True
            elif self.color == "black" and new_grid_y == original_grid_y + 1 and (new_grid_x == original_grid_x + 1 or new_grid_x == original_grid_x - 1) and self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_piece":
                self.valid_move = True
        elif self.targetting == True:
            if self.color == "white" and new_grid_y == original_grid_y - 1 and (new_grid_x == original_grid_x + 1 or new_grid_x == original_grid_x - 1) and self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True
            elif self.color == "black" and new_grid_y == original_grid_y + 1 and (new_grid_x == original_grid_x + 1 or new_grid_x == original_grid_x - 1) and self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True


        # pawn cant move forward if there is a figure in front of it
        if new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":
            self.valid_move = False
            return

        # # If pawn moves more than 2 squares, it is not a valid move
        # if abs(new_grid_y - original_grid_y) > 2:
        #     self.valid_move = False
        #     return

        super(Pawn, self).validate_move(chessboard)
    
class Rook(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Rook, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    
    def validate_move(self, chessboard):

        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()



        # rook canot jump above the figures, so if there is a figure in the way of the rook, it cannot move further
        if new_grid_x == original_grid_x:
            if new_grid_y > original_grid_y:
                for i in range(original_grid_y + 1, new_grid_y):
                    if self.chessboard.current_board_state[i][new_grid_x] != "Empty":
                        self.valid_move = False
                        return
            else:
                for i in range(new_grid_y + 1, original_grid_y):
                    if self.chessboard.current_board_state[i][new_grid_x] != "Empty":
                        self.valid_move = False
                        return
        elif new_grid_y == original_grid_y:
            if new_grid_x > original_grid_x:
                for i in range(original_grid_x + 1, new_grid_x):
                    if self.chessboard.current_board_state[new_grid_y][i] != "Empty":
                        self.valid_move = False
                        return
            else:
                for i in range(new_grid_x + 1, original_grid_x):
                    if self.chessboard.current_board_state[new_grid_y][i] != "Empty":
                        self.valid_move = False
                        return

        # rook cannot move on other than vertical or horizontal direction
        if new_grid_x != original_grid_x and new_grid_y != original_grid_y:
            self.valid_move = False
            return
        else:
            self.valid_move = True


        super(Rook, self).validate_move(chessboard)


class Knight(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Knight, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def validate_move(self, chessboard):
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # knight can move in L shape, so it can move to 8 different positions
        if abs(new_grid_x - original_grid_x) == 2 and abs(new_grid_y - original_grid_y) == 1:
            self.valid_move = True
        elif abs(new_grid_x - original_grid_x) == 1 and abs(new_grid_y - original_grid_y) == 2:
            self.valid_move = True
        else:
            self.valid_move = False
            return


        super(Knight, self).validate_move(chessboard)

class Bishop(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Bishop, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def validate_move(self, chessboard):
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # bishop can move diagonally, so the difference between the x and y coordinates should be the same
        if abs(new_grid_x - original_grid_x) != abs(new_grid_y - original_grid_y):
            self.valid_move = False
            return
        else:
            # check if there is a piece in the way of the bishop
            x_direction = 1 if new_grid_x > original_grid_x else -1
            y_direction = 1 if new_grid_y > original_grid_y else -1
            x, y = original_grid_x + x_direction, original_grid_y + y_direction
            while x != new_grid_x and y != new_grid_y:
                if self.chessboard.current_board_state[y][x] != "Empty":
                    self.valid_move = False
                    return
                x += x_direction
                y += y_direction

        if self.targetting == False:
        # if there is a friendly figure on the destination square, the queen cannot move to this position
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] in [self.color + "_piece", self.color + "_king"]:
                self.valid_move = False
                return
        elif self.targetting == True:
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True

        super(Bishop, self).validate_move(chessboard)

class Queen(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Queen, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard


    def validate_move(self, chessboard):
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # queen can move horizontally, vertically, or diagonally
        if new_grid_x != original_grid_x and new_grid_y != original_grid_y and abs(new_grid_x - original_grid_x) != abs(new_grid_y - original_grid_y):
            self.valid_move = False
            return

        # check if there is a piece in the way of the queen
        x_direction = 0 if new_grid_x == original_grid_x else 1 if new_grid_x > original_grid_x else -1
        y_direction = 0 if new_grid_y == original_grid_y else 1 if new_grid_y > original_grid_y else -1
        x, y = original_grid_x + x_direction, original_grid_y + y_direction
        while x != new_grid_x or y != new_grid_y:
            if self.chessboard.current_board_state[y][x] != "Empty":
                self.valid_move = False
                return
            x += x_direction
            y += y_direction

        if self.targetting == False:
        # if there is a friendly figure on the destination square, the queen cannot move to this position
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] in [self.color + "_piece", self.color + "_king"]:
                self.valid_move = False
                return
        elif self.targetting == True:
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True

        super(Queen, self).validate_move(chessboard)

class King(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(King, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard
        self.isKing = True

    def validate_move(self, chessboard):
        
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # king can move one square in any direction
        if abs(new_grid_x - original_grid_x) > 1 or abs(new_grid_y - original_grid_y) > 1:
            self.valid_move = False
            return


        super(King, self).validate_move(chessboard)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())