# TO DO
# Roszada
# zbieranie ruchów
# Zegar
# Warunek wygranej
# poruszanie figur notacją szachową

import sys
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QVBoxLayout, QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsItem
from PyQt5.QtSvg import QGraphicsSvgItem
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtCore import Qt, QPointF

import threading
import time   

class ClockThread(threading.Thread):
    def __init__(self, chessboard, TimeAmount):
        threading.Thread.__init__(self)
        self.chessboard = chessboard
        self.TimeAmount = TimeAmount

    def run(self, TimeAmount):
        while True:
            time.sleep(1)
            self.TimeAmount -= 1
            if self.TimeAmount == 0:
                self.chessboard.switchTurnsAndAddOneToTurnTimer()
                self.TimeAmount = 60

class ChessBoard(QGraphicsView):
    def __init__(self, *args, **kwargs):
        super(ChessBoard, self).__init__(*args, **kwargs)
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.drawBoard()
        self.setFixedSize(900, 640)
        self.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        self.addPieces()
        self.current_turn = 'white'  # White starts the game
        self.current_board_state = [[0 for _ in range(8)] for _ in range(8)]
        self.turnTimer = 0
        self.setStartingboardState()


        # Opcjonalnie, możesz tutaj ustawić rozmiar widoku, aby pasował do rozmiaru sceny
        self.scene.setSceneRect(0, 0, 640, 640)  # Zakładając, że rozmiar planszy to 640x640
        self.setFixedSize(900 + 2, 640 + 2)  # +2 dla marginesu; dostosuj według potrzeb

    def can_castle(self, king, rook):
        # Check if the king and rook have not moved
        if king.has_moved or rook.has_moved:
            return False

        # Mechanic that Check if the squares between the king and rook are empty
        for i in range(1, 3):
            if self.current_board_state[king.original_grid_y][king.original_grid_x + i] != "Empty":
                return False

        # Mechanic that Check if the king is in check
        

        # Check if the squares the king crosses are attacked


        return True

    def get_king(self, color):
        for piece in self.get_all_pieces(color):
            if piece.isKing:
                return piece

    def get_all_pieces(self, color):
        pieces = []
        for item in self.scene.items():
            if isinstance(item, ChessPiece) and item.color == color:
                pieces.append(item)
        return pieces
    
    def opposite_color(self, color):
        return 'white' if color == 'black' else 'black'
    
    def friendly_color(self, color):
        return 'black' if color == 'black' else 'white'

    def can_move(self, piece, position):
        # Check if the piece can move to the position
        piece.setPos(position.x(), position.y())
        piece.validate_move(self)
        if piece.valid_move:
            return True

        return False

    def is_check(self, color):
        # Get the position of the king
        king_position = self.get_king(self.opposite_color(color))

        # Print king position in terminal with grid coordinates
        print(king_position.getStartingGridPosition())

        # After move the code check all enemy pieces if they can move to the king position
        for piece in self.get_all_pieces(self.opposite_color(color)):
            if self.can_move(piece, king_position.pos()):
                return True

        # The king is not in check
        return False

    # Method to switch turns
    def switchTurnsAndAddOneToTurnTimer(self):
        self.current_turn = 'black' if self.current_turn == 'white' else 'white'

        # Add one to the turn timer
        self.turnTimer += 1

    def is_checkmate(self, color):
        # Check if the king is in check
        if not self.is_check(color):
            return False

        # Check if the king can move to a safe position
        king = self.get_king(color)
        for i in range(8):
            for j in range(8):
                if self.can_move(king, QPointF(i * 80, j * 80)):
                    return False

        # Check if any piece can capture the attacking piece
        for piece in self.get_all_pieces(color):
            for i in range(8):
                for j in range(8):
                    if self.can_move(piece, QPointF(i * 80, j * 80)):
                        return False

        return True

    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)

    def addPieces(self):
        # Black pieces
        self.addPiece(Rook("pieces/black/brook.svg", 0, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 1, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 2, 0, 'black',self))
        self.addPiece(Queen("pieces/black/bqueen.svg", 3, 0, 'black',self))
        self.addPiece(King("pieces/black/bking.svg", 4, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 5, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 6, 0, 'black',self))
        self.addPiece(Rook("pieces/black/brook.svg", 7, 0, 'black',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/black/bpawn.svg", i, 1, 'black', self))
        
        # White pieces
        self.addPiece(Rook("pieces/white/wrook.svg", 0, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 1, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 2, 7, 'white',self))
        self.addPiece(Queen("pieces/white/wqueen.svg", 3, 7, 'white',self))
        self.addPiece(King("pieces/white/wking.svg", 4, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 5, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 6, 7, 'white',self))
        self.addPiece(Rook("pieces/white/wrook.svg", 7, 7, 'white',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/white/wpawn.svg", i, 6, 'white', self))

    def addPiece(self, piece):
        self.scene.addItem(piece)

    def setStartingboardState(self):

        # Empty spaces
        for i in range(2, 6):
            for j in range(8):
                self.current_board_state[i][j] = "Empty"

        for i in range(8):
            for j in range(2):
                if i == 0 and j == 4:
                    self.current_board_state[j][i] = "black_king"
                else:
                    self.current_board_state[j][i] = "black_piece"

        for i in range(8):
            for j in range(6, 8):
                if i == 7 and j == 4:
                    self.current_board_state[j][i] = "white_king"
                else:
                    self.current_board_state[j][i] = "white_piece"

    def getBoardState(self):
        return self.current_board_state

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Przykład aplikacji')
        self.setFixedSize(900, 640)  # Ustawia pozycję i rozmiar głównego okna

        # Tworzy i umieszcza szachownicę
        self.chessBoard = ChessBoard(self)
        self.chessBoard.setGeometry(0, 0, 640, 640)  # Ustawia pozycję i rozmiar szachownicy

        # Tworzy i umieszcza przyciski
        self.createButton(800, 20, 'Przycisk 1')
        self.createButton(800, 50, 'Przycisk 2')

    def createButton(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onButtonClick)

    def onButtonClick(self):
        print("Kliknięto przycisk")
    
class ChessPiece(QGraphicsSvgItem):
    def __init__(self, image_path, x, y, color, chessboard):
        super(ChessPiece, self).__init__(image_path)
        self.setPos(x * 80, y * 80)
        self.default_scale = 1.8
        self.setScale(self.default_scale)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemIsSelectable)
        self.color = color
        self.chessboard = chessboard
        self.isKing = False
        self.valid_move = False
        self.direction = 1 if self.color == 'black' else -1
        self.oposite_color = 'white' if self.color == 'black' else 'black'
        self.original_grid_x = x
        self.original_grid_y = y

    def mousePressEvent(self, event):
        super(ChessPiece, self).mousePressEvent(event)

        # Store the current grid position when the mouse is pressed
        self.original_grid_x = int(self.x() / 80)
        self.original_grid_y = int(self.y() / 80)

    def validate_move(self, chessboard):

        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        # Check bounds
        if not (0 <= new_grid_x <= 7 and 0 <= new_grid_y <= 7):
            self.valid_move = False

        # checing condition if there is figure on the new position [exlcuding the case of pawn]
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":

            # cant move if there is friendly piece on the new position
            if self.color == 'black':
                if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_piece":
                    self.valid_move = False
                    return
                else:
                    self.valid_move = True
            elif self.color == 'white':
                if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_piece":
                    self.valid_move = False
                    return
                else:
                    self.valid_move = True

            # cannot move if there is a king piece in the new position
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_king" or self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_king":
                self.valid_move = False
                return

        # if the piece is not the color of the current turn, it cannot move
        if self.color != self.chessboard.current_turn:
            self.valid_move = False
            return


    def move_piece(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        self.validate_move(self.chessboard)

        # updating the board state and moving the piece if the move is valid
        if self.valid_move == True:
            self.cupture_piece()
            self.setPos(new_x, new_y)
            self.updateBoardStatus()
            self.chessboard.switchTurnsAndAddOneToTurnTimer()
            self.first_move = False
        elif self.valid_move == False:
            self.return_to_original_position()


    def cupture_piece(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        # remove piece that is being taken by player
        for item in self.scene().items():
            if isinstance(item, ChessPiece) and item.x() == new_x and item.y() == new_y:
                self.scene().removeItem(item)
                break

    def return_to_original_position(self):
        print("Return to original position")
        self.setPos(self.original_grid_x * 80, self.original_grid_y * 80)

    def mouseReleaseEvent(self, event):
        super(ChessPiece, self).mouseReleaseEvent(event)

        self.move_piece()

        self.setScale(self.default_scale)
        
        # Remove any existing move indicators from the scene
        for item in self.scene().items():
            if isinstance(item, QGraphicsRectItem) and item.brush().color() == QColor(0, 255, 0, 127):
                self.scene().removeItem(item)

    def updateBoardStatus(self):

        # prevoius move of the piece
        prev_x = round(self.original_grid_x * 80)
        prev_y = round(self.original_grid_y * 80)

        prev_grid_x = int(prev_x / 80)
        prev_grid_y = int(prev_y / 80)

        self.chessboard.current_board_state[prev_grid_y][prev_grid_x] = "Empty"

        # current move of the piece
        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)

        if self.color == 'black':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_piece"
        elif self.color == 'white':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_piece"

        # self.printCurrentBoardStateInTerminal()

    def calculate_position(self):

        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)


        return new_x, new_y, new_grid_x, new_grid_y
    
    def getStartingGridPosition(self):
        return self.original_grid_x, self.original_grid_y

    # only for debugging
    def printCurrentBoardStateInTerminal(self):
        for row in self.chessboard.current_board_state:
            print(row)
        print('\n')

    def getPreviousGridPosition(self):
        return self.original_grid_x, self.original_grid_y   

class Pawn(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Pawn, self).__init__(image_path, x, y, color, chessboard)  # Corrected parameter passing
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def validate_move(self, chessboard):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # pawn can move one square forward
        if self.color == "white" and new_grid_y == original_grid_y - 1 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
            self.valid_move = True
        elif self.color == "black" and new_grid_y == original_grid_y + 1 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
            self.valid_move = True
        # pawn can move two squares forward on its first move
        elif self.first_move and self.color == "white" and new_grid_y == original_grid_y - 2 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y + 1][new_grid_x] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
            self.valid_move = True
        elif self.first_move and self.color == "black" and new_grid_y == original_grid_y + 2 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y - 1][new_grid_x] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
            self.valid_move = True
        # pawn can only move diagonally when capturing an opponent's piece
        elif abs(new_grid_x - original_grid_x) == 1 and ((self.color == "white" and new_grid_y == original_grid_y - 1) or (self.color == "black" and new_grid_y == original_grid_y + 1)) and self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":
            self.valid_move = True
        # else:
        #     self.valid_move = False
        #     return

        if self.valid_move:
            self.first_move = False


        super(Pawn, self).validate_move(chessboard)
    
class Rook(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Rook, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard
        self.has_moved = False
    
    def validate_move(self, chessboard):

        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()



        # rook canot jump above the figures, so if there is a figure in the way of the rook, it cannot move further
        if new_grid_x == original_grid_x:
            if new_grid_y > original_grid_y:
                for i in range(original_grid_y + 1, new_grid_y):
                    if self.chessboard.current_board_state[i][new_grid_x] != "Empty":
                        self.valid_move = False
                        return
            else:
                for i in range(new_grid_y + 1, original_grid_y):
                    if self.chessboard.current_board_state[i][new_grid_x] != "Empty":
                        self.valid_move = False
                        return
        elif new_grid_y == original_grid_y:
            if new_grid_x > original_grid_x:
                for i in range(original_grid_x + 1, new_grid_x):
                    if self.chessboard.current_board_state[new_grid_y][i] != "Empty":
                        self.valid_move = False
                        return
            else:
                for i in range(new_grid_x + 1, original_grid_x):
                    if self.chessboard.current_board_state[new_grid_y][i] != "Empty":
                        self.valid_move = False
                        return

        # rook cannot move on other than vertical or horizontal direction
        if new_grid_x != original_grid_x and new_grid_y != original_grid_y:
            self.valid_move = False
            return
        else:
            self.valid_move = True


        # if there is a friendly figure in the way of the rook or enemy king, it cannot move on this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            self.valid_move = False
            return
        else:
            self.valid_move = True

        super(Rook, self).validate_move(chessboard)

        # super(Rook, self).mouseReleaseEvent(event)

class Knight(ChessPiece):

    def validate_move(self, chessboard):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # knight can move in L shape, so it can move to 8 different positions
        if abs(new_grid_x - original_grid_x) == 2 and abs(new_grid_y - original_grid_y) == 1:
            self.valid_move = True
        elif abs(new_grid_x - original_grid_x) == 1 and abs(new_grid_y - original_grid_y) == 2:
            self.valid_move = True
        else:
            self.valid_move = False
            return

        # if there is a friendly figure in the way of the knight or enemy king, it cannot move on this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            self.valid_move = False
            return
        else:
            self.valid_move = True

        super(Knight, self).validate_move(chessboard)

class Bishop(ChessPiece):
    def validate_move(self, chessboard):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # bishop can move diagonally, so the difference between the x and y coordinates should be the same
        if abs(new_grid_x - original_grid_x) != abs(new_grid_y - original_grid_y):
            self.valid_move = False
            return
        else:
            # check if there is a piece in the way of the bishop
            x_direction = 1 if new_grid_x > original_grid_x else -1
            y_direction = 1 if new_grid_y > original_grid_y else -1
            x, y = original_grid_x + x_direction, original_grid_y + y_direction
            while x != new_grid_x and y != new_grid_y:
                if self.chessboard.current_board_state[y][x] != "Empty":
                    self.valid_move = False
                    return
                x += x_direction
                y += y_direction

        # if there is a friendly figure or enemy king on the destination square, the bishop cannot move to this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            self.valid_move = False
            return
        else:
            self.valid_move = True

        super(Bishop, self).validate_move(chessboard)

class Queen(ChessPiece):

    def validate_move(self, chessboard):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # queen can move horizontally, vertically, or diagonally
        if new_grid_x != original_grid_x and new_grid_y != original_grid_y and abs(new_grid_x - original_grid_x) != abs(new_grid_y - original_grid_y):
            self.valid_move = False
            return

        # check if there is a piece in the way of the queen
        x_direction = 0 if new_grid_x == original_grid_x else 1 if new_grid_x > original_grid_x else -1
        y_direction = 0 if new_grid_y == original_grid_y else 1 if new_grid_y > original_grid_y else -1
        x, y = original_grid_x + x_direction, original_grid_y + y_direction
        while x != new_grid_x or y != new_grid_y:
            if self.chessboard.current_board_state[y][x] != "Empty":
                self.valid_move = False
                return
            x += x_direction
            y += y_direction

        # if there is a friendly figure or enemy king on the destination square, the queen cannot move to this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            self.valid_move = False
            return
        else:
            self.valid_move = True 

        super(Queen, self).validate_move(chessboard)

class King(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(King, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard
        self.isKing = True
        self.has_moved = False

    def validate_move(self, chessboard):
        
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # king can move one square in any direction
        if abs(new_grid_x - original_grid_x) > 1 or abs(new_grid_y - original_grid_y) > 1:
            self.valid_move = False
            return

        # if there is a friendly figure or enemy king on the destination square, the king cannot move to this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            self.valid_move = False
            return
        else:
            self.valid_move = True

        super(King, self).validate_move(chessboard)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())