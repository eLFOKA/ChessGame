# TO DO
# Roszada - ----------------------------------------------------- Done! Do poprawki lekkiej potem # TO DO LIST
# zbieranie ruchów - JEST! tylko okienko dorobić ---------------- DOONEE!!!!
# Zegar - Prawie jest teraz tylko do warunku wygranej i końca gry
# Warunek wygranej -  NO w miare git ale dalej do poprienia
# poruszanie figur notacją szachową

import sys
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QVBoxLayout, QLabel,  QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsItem, QLineEdit, QTextEdit
from PyQt5.QtSvg import QGraphicsSvgItem
from PyQt5.QtGui import QBrush, QColor, QFont, QKeyEvent, QTextOption
from PyQt5.QtCore import Qt, QPointF, QThread, pyqtSignal


import threading
import time   

class ClockThread(QThread):
<<<<<<< Updated upstream
    def __init__(self, mainWindow, timeAmount, chessboard, parent=None):
=======
    updateClock = pyqtSignal(str, str)  # Sygnał do aktualizacji etykiet zegarów

    def __init__(self, parent=None):s
>>>>>>> Stashed changes
        super().__init__(parent)
        self.timeAmount = timeAmount
        self.chessboard = chessboard
        self.mainWindow = mainWindow
        self.TimeAmount = 0

    def run(self):
        while True:
            time.sleep(1)
            self.TimeAmount -= 1
            self.mainWindow.updateLabel(f"{self.TimeAmount // 60}:{self.TimeAmount % 60}")
            if self.TimeAmount == 0:
                print("Time is up")
    
    def set(self, timeAmount):
        self.TimeAmount = timeAmount

<<<<<<< Updated upstream
=======
            # Formatowanie czasu i wysyłanie sygnału do aktualizacji etykiet
            whiteText = f"{self.whiteTime // 60}:{self.whiteTime % 60:02d}"
            blackText = f"{self.blackTime // 60}:{self.blackTime % 60:02d}"
            self.updateClock.emit(whiteText, blackText)

    def setTime(self, whiteTime, blackTime):
        self.whiteTime = whiteTime
        self.blackTime = blackTime

    def switchColor(self):
        if self.activeColor == 'white':
            self.activeColor = 'black'
        elif self.activeColor == 'black':
            self.activeColor = 'white'

    def stop(self):
        self.running = False
>>>>>>> Stashed changes

class ChessBoard(QGraphicsView):
    # Signal to emit move in chess notation
    moveMade = pyqtSignal(str)
<<<<<<< Updated upstream
=======
    switchTurnSignal = pyqtSignal()
>>>>>>> Stashed changes

    def __init__(self, *args, **kwargs):
        super(ChessBoard, self).__init__(*args, **kwargs)
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.drawBoard()
        self.setFixedSize(900, 640)
        self.setAlignment(Qt.AlignLeft | Qt.AlignTop)
        self.addPieces()
        self.current_turn = 'white'  # White starts the game
        self.current_board_state = [[0 for _ in range(8)] for _ in range(8)]
        self.turnTimer = 0
        self.setStartingboardState()
        self.isCheck = False
        self.witchKingisCheck = None
        self.gameStarted = False
        # self.x_grid_position_for_enter_move = None # Stupid ass fuck but lets try it
        # self.y_grid_position_for_enter_move = None
        self.last_moved_piece = None


        # Opcjonalnie, możesz tutaj ustawić rozmiar widoku, aby pasował do rozmiaru sceny
        self.scene.setSceneRect(0, 0, 640, 640)  # Zakładając, że rozmiar planszy to 640x640
        self.setFixedSize(900 + 2, 640 + 2)  # +2 dla marginesu; dostosuj według potrzeb

    def oposite_color(self, color):
        return 'white' if color == 'black' else 'black'
    
    def can_castle(self, king, rook):
        # Check if the king and rook have not moved
        if king.has_moved or rook.has_moved:
            return False

        # Mechanic that Check if the squares between the king and rook are empty
        for i in range(1, 3):
            if self.current_board_state[king.original_grid_y][king.original_grid_x + i] != "Empty":
                return False

        # Mechanic that check if king is in check


        # Check if the squares the king crosses are attacked


        return True

    def get_king(self, color):
        for piece in self.get_all_pieces(color):
            if piece.isKing == True and piece.color == color:
                # print(f"King {piece.color} {piece.__class__.__name__} is in {piece.pos()}")
                return piece

    def get_all_pieces(self, color):
        pieces = []
        for item in self.scene.items():
            if isinstance(item, ChessPiece) and item.color == color:
                pieces.append(item)
        
        # print(f"Number of {color} pieces: {len(pieces)}")
        return pieces
    
    def friendly_color(self, color):
        return 'black' if color == 'black' else 'white'

    def can_move(self, piece, position):
        # Check if the piece can move to the position
        piece.targetting = True
        piece.target_Position_x = position.x()
        piece.target_Position_y = position.y()
        piece.validate_move(self)
        #print if the move is valid for figure
        # print(f"figure {piece.color} {piece.__class__.__name__} has {piece.valid_move} move to {position.x(), position.y()}")
        #print(f"figure {piece.color} {piece.__class__.__name__} is in {piece.pos()} and wants to move to {position.x(), position.y()}")
        if piece.valid_move:
            # print(f"figure {piece.color} {piece.__class__.__name__} can move to {position.x(), position.y()}")
            piece.valid_move = False
            piece.targetting = False
            return True
        
        piece.targetting = False
        return False

    def is_check(self, color):
        # Get the position of the king
        king_position = self.get_king(self.oposite_color(color))
        # print oposite color
        # print(f"Oposite color: {self.oposite_color(color)}")

        # After move, code checks all friendly pieces if they can move to the enemy king position
        for piece in self.get_all_pieces(color):
            # print(f" {piece.pieceName}")
            if self.can_move(piece, king_position.pos()):
                print(f"Check by {piece.color} {piece.__class__.__name__}")
                print (f"King {king_position.color} {king_position.__class__.__name__} is in {king_position.pos()}")
                print(f"figure position is {piece.pos()}")
                # print king position that is in check
                #print(f"King {king_position.color} {king_position.__class__.__name__} is in {king_position.pos()}")   
                return True

        return False

    # need to be tested
    def perform_castling(self, king, rook):
        if not self.can_castle(king, rook):
            return False
        
        # Określ pozycje docelowe dla króla i wieży na podstawie ich obecnej pozycji
        if rook.original_grid_x == 0:  # Roszada długa
            king_target_x = 2
            rook_target_x = 3
        else:  # Roszada krótka
            king_target_x = 6
            rook_target_x = 5
        
        # Ustaw pozycje króla i wieży
        king.setPos(king_target_x * 80, king.original_grid_y * 80)
        rook.setPos(rook_target_x * 80, rook.original_grid_y * 80)
        
        # Uaktualnij stan planszy
        self.current_board_state[king.original_grid_y][king.original_grid_x] = "Empty"
        self.current_board_state[rook.original_grid_y][rook.original_grid_x] = "Empty"
        self.current_board_state[king.original_grid_y][king_target_x] = king.color + "_king"
        self.current_board_state[rook.original_grid_y][rook_target_x] = rook.color + "_piece"
        
        # Oznacz króla i wieżę jako poruszone
        king.has_moved = True
        rook.has_moved = True
        
        return True


    # Method to switch turns
    def switchTurnsAndAddOneToTurnTimer(self):
        self.current_turn = 'black' if self.current_turn == 'white' else 'white'
        self.turnTimer += 1
<<<<<<< Updated upstream

        # # Check if there is a check
        # if self.is_check(self.current_turn):
        #     print(f"Check by {self.current_turn}")
=======
        self.switchTurnSignal.emit() 
>>>>>>> Stashed changes

    def is_checkmate(self, color):
        # Check if the king is in check
        if not self.is_check(color):
            return False

        # Check if the king can move to a safe position
        king = self.get_king(color)
        for i in range(8):
            for j in range(8):
                if self.can_move(king, QPointF(i * 80, j * 80)):
                    return False

        # Check if any piece can capture the attacking piece
        for piece in self.get_all_pieces(color):
            for i in range(8):
                for j in range(8):
                    if self.can_move(piece, QPointF(i * 80, j * 80)):
                        return False

        return True

    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)

    def addPieces(self):
        # Black pieces
        self.addPiece(Rook("pieces/black/brook.svg", 0, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 1, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 2, 0, 'black',self))
        self.addPiece(Queen("pieces/black/bqueen.svg", 3, 0, 'black',self))
        self.addPiece(King("pieces/black/bking.svg", 4, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 5, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 6, 0, 'black',self))
        self.addPiece(Rook("pieces/black/brook.svg", 7, 0, 'black',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/black/bpawn.svg", i, 1, 'black', self))
        
        # White pieces
        self.addPiece(Rook("pieces/white/wrook.svg", 0, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 1, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 2, 7, 'white',self))
        self.addPiece(Queen("pieces/white/wqueen.svg", 3, 7, 'white',self))
        self.addPiece(King("pieces/white/wking.svg", 4, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 5, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 6, 7, 'white',self))
        self.addPiece(Rook("pieces/white/wrook.svg", 7, 7, 'white',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/white/wpawn.svg", i, 6, 'white', self))

    def addPiece(self, piece):
        self.scene.addItem(piece)

    def setStartingboardState(self):

        # Empty spaces
        for i in range(2, 6):
            for j in range(8):
                self.current_board_state[i][j] = "Empty"

        for i in range(8):
            for j in range(2):
                self.current_board_state[j][i] = "black_piece"

        for i in range(8):
            for j in range(6, 8):
                self.current_board_state[j][i] = "white_piece"
                
        self.current_board_state[7][4] = "white_king"     
        self.current_board_state[0][4] = "black_king"

    def getBoardState(self):
        return self.current_board_state
    
    def returnFigurePositionToChessCordinates(self, piece):

        # Use integer division to avoid potential floating-point inaccuracies
        grid_x = int(round(piece.x() / 80))
        grid_y = int(round(piece.y() / 80))

        # Map the grid position to chess coordinates
        chess_columns = "abcdefgh"
        if 0 <= grid_x < 8:
            xChessCordinate = chess_columns[grid_x]
        else:
            xChessCordinate = 'a'  # Default value or handle error


        # Assuming the y-coordinate is always valid, but you might want to check this as well
        yChessCordinate = 8 - grid_y

        # change piece class name to chess notation
        pieceName = piece.__class__.__name__
        if pieceName == "Pawn":
            pieceName = ""
        elif pieceName == "Rook":
            pieceName = "R"
        elif pieceName == "Knight":
            pieceName = "N"
        elif pieceName == "Bishop":
            pieceName = "B"
        elif pieceName == "Queen":
            pieceName = "Q"
        elif pieceName == "King":
            pieceName = "K"

        # Sum the coordinates of the figure and pieceName
        figurePositionInChessCordinates = pieceName + xChessCordinate + str(yChessCordinate)

        return figurePositionInChessCordinates

    def returnChessCordinatesToFigurePosition(self, string):
        x = None  # Ustaw wartość domyślną dla x
        y = None  # Ustaw wartość domyślną dla y
        figureName = None  # Ustaw wartość domyślną dla figureName
        
        if len(string) == 2:
            figureName = "Pawn"

            if string[0] == 'a':
                x = 0
            elif string[0] == 'b':
                x = 1
            elif string[0] == 'c':
                x = 2
            elif string[0] == 'd':
                x = 3
            elif string[0] == 'e':
                x = 4
            elif string[0] == 'f':
                x = 5
            elif string[0] == 'g':
                x = 6
            elif string[0] == 'h':
                x = 7

            y = (8 - int(string[1]))
        elif len(string) == 3:
            if string[0] == "R":
                figureName = "Rook"
            elif string[0] == "N":
                figureName = "Knight"
            elif string[0] == "B":
                figureName = "Bishop"
            elif string[0] == "Q":
                figureName = "Queen"
            elif string[0] == "K":
                figureName = "King"

            if string[1] == 'a':
                x = 0
            elif string[1] == 'b':
                x = 1
            elif string[1] == 'c':
                x = 2
            elif string[1] == 'd':
                x = 3
            elif string[1] == 'e':
                x = 4
            elif string[1] == 'f':
                x = 5
            elif string[1] == 'g':
                x = 6
            elif string[1] == 'h':
                x = 7
            
            y = (8 - int(string[2]))
        return x, y, figureName


class MainWindow(QWidget):
    def __init__(self, chessboard):
        super().__init__()
        self.setWindowTitle('Chess Game by Maksymilian Anzulewicz Beta 0.1')
        self.setFixedSize(900, 640)
        self.chessBoard = chessboard
<<<<<<< Updated upstream
        self.Clock = ClockThread(self, 0, chessboard)
        self.insideTimer = 0
=======
        self.insideTimer = 0

        # Inicjalizacja ClockThread
        self.clockThread = ClockThread()
        # Nawiązanie połączenia sygnału z metodą
        self.clockThread.updateClock.connect(self.updateClocks)
        # Ustaw początkowy czas zegarów, na przykład na 15 minut dla każdego gracza
        self.clockThread.setTime(15*60, 15*60)

        self.chessBoard.switchTurnSignal.connect(self.switchClockColor)
>>>>>>> Stashed changes

        # creates chess board
        self.chessBoard.__init__(self)
        self.chessBoard.setGeometry(0, 0, 640, 640) 

        # creates button for starting the game
        self.createButtonSTART(700, 20, 'START')
        self.createButton2(700, 50, 'Przycisk 2')

        # creates buttons for time
        self.createButtonTime1(700, 120, 'Time 10 min')
        self.createButtonTime2(700, 150, 'Time 1 min')

        # creates label for time
        self.label = QLabel(self)
        self.label.setText("00:00")
        self.label.move(710, 80) 
        self.label.resize(110, 40)
        font = QFont("Arial", 20)
        self.label.setFont(font)

<<<<<<< Updated upstream
=======
        # creates labels for time for white and black
        self.whiteClockLabel = QLabel("15:00", self)
        self.whiteClockLabel.move(660, 40)
        self.whiteClockLabel.resize(60, 40)
        self.blackClockLabel = QLabel("15:00", self)
        self.blackClockLabel.move(660, 80)
        self.blackClockLabel.resize(60, 40)

>>>>>>> Stashed changes
        #create text field for adding logs
        self.text_field = QTextEdit(self)
        self.text_field.move(700, 200)
        self.text_field.resize(180, 50)


        # creates text field for showing chess moves in chess notation
        self.text_field2 = QTextEdit(self)
        self.text_field2.move(700, 300)
        self.text_field2.resize(180, 400)
        self.text_field2.setPlaceholderText("Enter chess notation")
        self.text_field2.setReadOnly(True)
        self.text_field2.setAlignment(Qt.AlignTop)
        # tekst musi się zawijać
        self.text_field2.setWordWrapMode(QTextOption.WordWrap)

        # for reading keys from keyboard
        self.setFocusPolicy(Qt.StrongFocus)


        # Connect the moveMade signal to the slot
        self.chessBoard.moveMade.connect(self.updateMoveLog)


    def updateMoveLog(self, move_notation):
        # Method to update the QTextEdit or QLineEdit with the move notation
        current_text = self.text_field2.toPlainText()
        new_text = f"{current_text}\n{move_notation}"  # Append the new move
        self.text_field2.setText(new_text)  # For QLineEdit
        # If you're using QTextEdit, you might prefer: self.text_field2.append(move_notation)

    def updateLabel(self, text):
        self.label.setText(text)

    def updateTextField2(self, text):
        if self.insideTimer == 0:
            return
        else:
            text = self.chessBoard.returnFigurePositionToChessCordinates(self.chessBoard.last_moved_piece)
            self.text_field2.setText(text)
            self.insideTimer += 1

    # reading text from text field
    def readTextField(self):
        text = self.text_field.text()
        return text

    def createButtonSTART(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onButtonClickSTART)
        button.resize(100, 30)
    def createButton2(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onButtonClick2)
        button.resize(100, 30)

    # Buttons for time
    def createButtonTime1(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onTimeButtonClick1)
        button.resize(100, 30)
    def createButtonTime2(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onTimeButtonClick2)
        button.resize(100, 30)
    
    # Logic in buttons for time
    def onTimeButtonClick1(self):
<<<<<<< Updated upstream
        self.Clock.set(600)
        self.updateLabel("10:00")
    def onTimeButtonClick2(self):
        self.Clock.set(60)
        self.updateLabel("01:00")
=======
        self.clockThread.setTime(600, 600)
        self.updateClocks("10:00", "10:00")
    def onTimeButtonClick2(self):
        self.clockThread.setTime(60, 60)
        self.updateClocks("01:00", "01:00")
>>>>>>> Stashed changes

    def createWindowContainer(self, x, y, width, height, text):
        self.windowContainer = QWidget(self)
        self.windowContainer.setGeometry(x, y, width, height)
        self.windowContainer.setWindowTitle(text)

    def onButtonClickSTART(self):
        self.chessBoard.gameStarted = True
        self.Clock.start()
        print("Game has started")

    def onButtonClick2(self):
        self.clockThread.switchColor()
        print("Kliknięto przycisk")

class ChessPiece(QGraphicsSvgItem):
    def __init__(self, image_path, x, y, color, chessboard):
        super(ChessPiece, self).__init__(image_path)
        self.setPos(x * 80, y * 80)
        self.default_scale = 1.8
        self.setScale(self.default_scale)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemIsSelectable)
        self.color = color
        self.chessboard = chessboard
        self.isKing = False
        self.valid_move = False
        self.direction = 1 if self.color == 'black' else -1
        self.oposite_color = 'white' if self.color == 'black' else 'black'
        self.original_grid_x = x
        self.original_grid_y = y
        self.target_Position_x = 0
        self.target_Position_y = 0
        self.targetting = False # i know its so stupid but i dont know how to do it better
        self.pieceName = self.__class__.__name__
        # self.enterPressedMove = False
        self.hasmoved = False

    def mousePressEvent(self, event):
        super(ChessPiece, self).mousePressEvent(event)

        # Store the current grid position when the mouse is pressed
        self.original_grid_x = int(self.x() / 80)
        self.original_grid_y = int(self.y() / 80)

    def validate_move(self, chessboard):

        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        # Check bounds
        if not (0 <= new_grid_x <= 7 and 0 <= new_grid_y <= 7):
            self.valid_move = False
            return

        # # checing condition if there is figure on the new position [exlcuding the case of pawn]
        # if self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":

        #     # cant move if there is friendly piece on the new position
        #     if self.color == 'black':
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_piece", "black_king"]:
        #             self.valid_move = False
        #             return
        #     elif self.color == 'white':
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["white_piece", "white_king"]:
        #             self.valid_move = False
        #             return

        #     if self.targetting == False:
        #         # cannot move if there is a king piece in the new position
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_king" or self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_king":
        #             self.valid_move = False
        #             return
        #     elif self.targetting == True:
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_king" or self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_king":
        #             self.valid_move = True

        if self.targetting == False:
            # if the piece is not the color of the current turn, it cannot move
            if self.color != self.chessboard.current_turn:
                self.valid_move = False
                return
        elif self.targetting == True:
            if self.color != self.chessboard.current_turn:
                self.valid_move = True
        
        if self.targetting == False:
            if self.valid_move:
                self.first_move = False


        # check if color of the piece is the same as the color of the piece on the target position
        if self.color != self.chessboard.current_turn:
            self.valid_move = False
            return

        # correct way 
        if self.targetting == False:
        # if there is a friendly figure on the destination square, the queen cannot move to this position
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] in [self.color + "_piece", self.color + "_king", self.oposite_color + "_king"]:
                self.valid_move = False
                return
        elif self.targetting == True:
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True


        # print(f"is valid move after {self.valid_move}")

        # print("tu patrze jaka figura ma targetting position")
        # print(self.target_Position_x, self.target_Position_y)
        # self.valid_move = True

    def get_current_position(self):
        return self.x(), self.y()

    def cupture_piece(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        # remove piece that is being taken by player
        for item in self.scene().items():
            if isinstance(item, ChessPiece) and item.x() == new_x and item.y() == new_y:
                self.scene().removeItem(item)
                break

    def return_to_original_position(self):
        # print("Return to original position")
        self.setPos(self.original_grid_x * 80, self.original_grid_y * 80)

    def move_piece(self):

        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()


        self.validate_move(self.chessboard)
        # print("jestem po funkcji validate_move")
        # print(f" wartosc valid_move w move_piece = {self.valid_move}")
        if self.targetting == False:
            # updating the board state and moving the piece if the move is valid
            if self.valid_move == True:
                notation = self.chessboard.returnFigurePositionToChessCordinates(self)
                self.chessboard.moveMade.emit(notation)  # Emit the signal with the notation
                # print("update board state and move the piece")
                self.cupture_piece()
                self.setPos(new_x, new_y)
                self.updateBoardStatus()
                self.chessboard.switchTurnsAndAddOneToTurnTimer()
                self.first_move = False
                self.valid_move = False
                # print(self.chessboard.returnFigurePositionToChessCordinates(self))
                # print(f"figure {self.color} {self.__class__.__name__} moved to {self.calculate_position()}")
            elif self.valid_move == False:
                # print("get back to original position")
                self.return_to_original_position()

    def mouseReleaseEvent(self, event):
        super(ChessPiece, self).mouseReleaseEvent(event)

        if self.chessboard.gameStarted == True:
            self.setScale(self.default_scale)

            self.move_piece()

            # Check if there is a check
            if self.chessboard.is_check(self.color):
                print(f"Check by {self.color}")
            if self.chessboard.is_checkmate(self.oposite_color):
                print(f"Check by {self.oposite_color}")

            self.chessboard.last_moved_piece = self
        elif self.chessboard.gameStarted == False:
            print("Game has not started yet")
            self.return_to_original_position()

        #self.printCurrentBoardStateInTerminal()

        # # check if there is a check
        # if self.chessboard.is_check(self.color):
        #     print(f"Check by {self.color}")

    def updateBoardStatus(self):

        # prevoius move of the piece
        prev_x = round(self.original_grid_x * 80)
        prev_y = round(self.original_grid_y * 80)

        prev_grid_x = int(prev_x / 80)
        prev_grid_y = int(prev_y / 80)

        self.chessboard.current_board_state[prev_grid_y][prev_grid_x] = "Empty"

        # current move of the piece
        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)

        if self.color == 'black':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_piece"
        elif self.color == 'white':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_piece"

        # self.printCurrentBoardStateInTerminal()

    def calculate_position(self):

        # if self.enterPressedMove == False:
        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)

        # (f"new x: {new_grid_x}, new y: {new_grid_y} dla enterPressedMove = False")
        return new_x, new_y, new_grid_x, new_grid_y
        # elif self.enterPressedMove == True:

        #     new_grid_x = self.chessboard.x_grid_position_for_enter_move
        #     new_grid_y = self.chessboard.y_grid_position_for_enter_move

        #     new_x = new_grid_x * 80
        #     new_y = new_grid_y * 80

        #     print(f"new x: {new_grid_x}, new y: {new_grid_y} dla enterPressedMove = True")
        #     return new_x, new_y, new_grid_x, new_grid_y
    
    def getStartingGridPosition(self):
        return self.original_grid_x, self.original_grid_y

    # only for debugging
    def printCurrentBoardStateInTerminal(self):
        for row in self.chessboard.current_board_state:
            print(row)
        print('\n')

    def getPreviousGridPosition(self):
        return self.original_grid_x, self.original_grid_y   


class Pawn(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Pawn, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def validate_move(self, chessboard):
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)


        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # print(f"original grid x: {original_grid_x}, original grid y: {original_grid_y}")
        # print(f"new grid x: {new_grid_x}, new grid y: {new_grid_y}")

        # if self.targetting == True:
        #     print(original_grid_x, original_grid_y, new_grid_x, new_grid_y)

        # if self.first_move == False:
        #     # pawn can move one square forward
        #     if self.color == "white" and new_grid_y == original_grid_y - 1 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
        #         self.valid_move = True
        #     else:
        #         self.valid_move = False
        #         return
        #     if self.color == "black" and new_grid_y == original_grid_y + 1 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
        #         self.valid_move = True
        #     else:
        #         self.valid_move = False
        #         return
        # elif self.first_move == True:
        #     # pawn can move two squares forward on its first move
        #     if self.first_move and self.color == "white" and new_grid_y == original_grid_y - 2 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y + 1][new_grid_x] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
        #         self.valid_move = True
        #     else:
        #         self.valid_move = False
        #         return
        #     if self.first_move and self.color == "black" and new_grid_y == original_grid_y + 2 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y - 1][new_grid_x] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
        #         self.valid_move = True
        #     else:
        #         self.valid_move = False
        #         return
        # print(f"is valid move before {self.first_move}")
        # pawn movement mechanic
        if self.first_move == True:
            if new_grid_x != original_grid_x or abs(new_grid_y - original_grid_y) > 2:
                # print(new_grid_x == original_grid_x)
                # print(abs(new_grid_y - original_grid_y) > 2)
                self.valid_move = False
                return
            else:
                self.valid_move = True
        elif self.first_move == False:
            if abs(new_grid_x - original_grid_x) <= 1 and abs(new_grid_y - original_grid_y) == 1:
                self.valid_move = True
            else:
                self.valid_move = False
                return
        
        # pawn can only move diagonally when capturing an opponent's piece
        # if abs(new_grid_x - original_grid_x) == 1 and abs(new_grid_y - original_grid_y) == 1:
        #     if self.targetting == False:
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_piece":
        #             self.valid_move = True
        #     elif self.targetting == True:
        #         if self.chessboard.current_board_state[new_grid_y][new_grid_x] in [self.oposite_color + "_piece", self.oposite_color + "_king"]:
        #             self.valid_move = True
        
        # pawn can only move diagonally when capturing an opponent's piece
        if self.targetting == False:
            if self.color == "white" and new_grid_y == original_grid_y - 1 and (new_grid_x == original_grid_x + 1 or new_grid_x == original_grid_x - 1) and self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_piece":
                self.valid_move = True
            elif self.color == "black" and new_grid_y == original_grid_y + 1 and (new_grid_x == original_grid_x + 1 or new_grid_x == original_grid_x - 1) and self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_piece":
                self.valid_move = True
        elif self.targetting == True:
            if self.color == "white" and new_grid_y == original_grid_y - 1 and (new_grid_x == original_grid_x + 1 or new_grid_x == original_grid_x - 1) and self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True
            elif self.color == "black" and new_grid_y == original_grid_y + 1 and (new_grid_x == original_grid_x + 1 or new_grid_x == original_grid_x - 1) and self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True


        # # pawn cant move forward if there is a figure in front of it
        # if new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":
        #     self.valid_move = False
        #     return

        # pawn cant move forward if there is a figure in front of it
        if new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":
            self.valid_move = False
            return


        # If pawn moves more than 2 squares, it is not a valid move
        if abs(new_grid_y - original_grid_y) > 2:
             self.valid_move = False
             return

        super(Pawn, self).validate_move(chessboard)
    
class Rook(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Rook, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    
    def validate_move(self, chessboard):

        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()



        # rook canot jump above the figures, so if there is a figure in the way of the rook, it cannot move further
        if new_grid_x == original_grid_x:
            if new_grid_y > original_grid_y:
                for i in range(original_grid_y + 1, new_grid_y):
                    if self.chessboard.current_board_state[i][new_grid_x] != "Empty":
                        self.valid_move = False
                        return
            else:
                for i in range(new_grid_y + 1, original_grid_y):
                    if self.chessboard.current_board_state[i][new_grid_x] != "Empty":
                        self.valid_move = False
                        return
        elif new_grid_y == original_grid_y:
            if new_grid_x > original_grid_x:
                for i in range(original_grid_x + 1, new_grid_x):
                    if self.chessboard.current_board_state[new_grid_y][i] != "Empty":
                        self.valid_move = False
                        return
            else:
                for i in range(new_grid_x + 1, original_grid_x):
                    if self.chessboard.current_board_state[new_grid_y][i] != "Empty":
                        self.valid_move = False
                        return

        # rook cannot move on other than vertical or horizontal direction
        if new_grid_x != original_grid_x and new_grid_y != original_grid_y:
            self.valid_move = False
            return
        else:
            self.valid_move = True


        super(Rook, self).validate_move(chessboard)

class Knight(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Knight, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def validate_move(self, chessboard):
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # knight can move in L shape, so it can move to 8 different positions
        if abs(new_grid_x - original_grid_x) == 2 and abs(new_grid_y - original_grid_y) == 1:
            self.valid_move = True
        elif abs(new_grid_x - original_grid_x) == 1 and abs(new_grid_y - original_grid_y) == 2:
            self.valid_move = True
        else:
            self.valid_move = False
            return


        super(Knight, self).validate_move(chessboard)

class Bishop(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Bishop, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def validate_move(self, chessboard):
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # bishop can move diagonally, so the difference between the x and y coordinates should be the same
        if abs(new_grid_x - original_grid_x) != abs(new_grid_y - original_grid_y):
            self.valid_move = False
            return
        elif abs(new_grid_x - original_grid_x) == abs(new_grid_y - original_grid_y):
            self.valid_move = True

        # check if there is a piece in the way of the bishop
        x_direction = 1 if new_grid_x > original_grid_x else -1
        y_direction = 1 if new_grid_y > original_grid_y else -1
        x, y = original_grid_x + x_direction, original_grid_y + y_direction
        while x != new_grid_x and y != new_grid_y:
            if self.chessboard.current_board_state[y][x] != "Empty":
                self.valid_move = False
                return
            x += x_direction
            y += y_direction



        if self.targetting == False:
        # if there is a friendly figure on the destination square, the queen cannot move to this position
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] in [self.color + "_piece", self.color + "_king"]:
                self.valid_move = False
                return
        elif self.targetting == True:
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True

        super(Bishop, self).validate_move(chessboard)

class Queen(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Queen, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard


    def validate_move(self, chessboard):
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # queen can move horizontally, vertically, or diagonally
        if new_grid_x != original_grid_x and new_grid_y != original_grid_y and abs(new_grid_x - original_grid_x) != abs(new_grid_y - original_grid_y):
            self.valid_move = False
            return
        else:
            self.valid_move = True

        # check if there is a piece in the way of the queen
        x_direction = 0 if new_grid_x == original_grid_x else 1 if new_grid_x > original_grid_x else -1
        y_direction = 0 if new_grid_y == original_grid_y else 1 if new_grid_y > original_grid_y else -1
        x, y = original_grid_x + x_direction, original_grid_y + y_direction
        while x != new_grid_x or y != new_grid_y:
            if self.chessboard.current_board_state[y][x] != "Empty":
                self.valid_move = False
                return
            x += x_direction
            y += y_direction

        if self.targetting == False:
        # if there is a friendly figure on the destination square, the queen cannot move to this position
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] in [self.color + "_piece", self.color + "_king"]:
                self.valid_move = False
                return
        elif self.targetting == True:
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == self.oposite_color + "_king":
                self.valid_move = True

        super(Queen, self).validate_move(chessboard)



class King(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(King, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard
        self.isKing = True

    def validate_move(self, chessboard):
        
        #mechanic for checking if the piece is targetting the position of king
        if self.targetting == False:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        elif self.targetting == True:
            new_x, new_y, new_grid_x, new_grid_y = self.target_Position_x, self.target_Position_y, int(self.target_Position_x / 80), int(self.target_Position_y / 80)

        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # king can move one square in any direction
        if abs(new_grid_x - original_grid_x) > 1 or abs(new_grid_y - original_grid_y) > 1:
            self.valid_move = False
            return


        super(King, self).validate_move(chessboard)


    def mouseReleaseEvent(self, event):
        
<<<<<<< Updated upstream
=======
        # zmiennaRobocza = False

>>>>>>> Stashed changes
        if chessboard.gameStarted == True:
            new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()            


            if self.color == "white":
                # mechanic for castling
                if self.first_move == True:
                    # for short castling
                    if new_grid_x == self.original_grid_x + 3 and new_grid_y == self.original_grid_y:
                        # Check if the squares between the king and rook are empty
                        if self.chessboard.current_board_state[new_grid_y][new_grid_x - 1] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x - 2] == "Empty":
                            # Check if the rook is in the correct position
                            for item in self.scene().items():
                                if isinstance(item, Rook) and item.getStartingGridPosition() == (7, 7) and item.first_move == True and item.color == self.color:
                                    item.setPos(5 * 80, new_grid_y * 80)
                                    item.updateBoardStatus()
                                    item.first_move = False
                                    self.chessboard.switchTurnsAndAddOneToTurnTimer()
                                    break
                            self.setPos((new_grid_x - 1) * 80, new_grid_y * 80)
                            self.updateBoardStatus()
                            self.first_move = False
<<<<<<< Updated upstream
                        elif self.chessboard.current_board_state[new_grid_y][new_grid_x - 1] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x - 2] != "Empty":
                            self.return_to_original_position()
=======
                            # zmiennaRobocza == True
                        elif self.chessboard.current_board_state[new_grid_y][new_grid_x - 1] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x - 2] != "Empty":
                            self.return_to_original_position()
                            return
>>>>>>> Stashed changes
                    # for long castling
                    if new_grid_x == self.original_grid_x - 4 and new_grid_y == self.original_grid_y:
                        # Check if the squares between the king and rook are empty
                        if self.chessboard.current_board_state[new_grid_y][new_grid_x + 1] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 2] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 3] == "Empty":
                            # Check if the rook is in the correct position
                            for item in self.scene().items():
                                if isinstance(item, Rook) and item.getStartingGridPosition() == (0, 7) and item.first_move == True and item.color == self.color:
                                    item.setPos(3 * 80, new_grid_y * 80)
                                    item.updateBoardStatus()
                                    item.first_move = False
                                    self.chessboard.switchTurnsAndAddOneToTurnTimer()
                                    break
                            self.setPos((new_grid_x + 2) * 80, new_grid_y * 80)
                            self.updateBoardStatus()
                            self.first_move = False
<<<<<<< Updated upstream
                        elif self.chessboard.current_board_state[new_grid_y][new_grid_x + 1] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 2] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 3] != "Empty":
                            self.return_to_original_position()
=======
                            # zmiennaRobocza == True
                        elif self.chessboard.current_board_state[new_grid_y][new_grid_x + 1] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 2] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 3] != "Empty":
                            self.return_to_original_position()
                            return
>>>>>>> Stashed changes
            elif self.color == "black":
                # mechanic for castling
                if self.first_move == True:
                    # for short castling
                    if new_grid_x == self.original_grid_x + 3 and new_grid_y == self.original_grid_y:
                        # Check if the squares between the king and rook are empty
                        if self.chessboard.current_board_state[new_grid_y][new_grid_x - 1] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x - 2] == "Empty":
                            # Check if the rook is in the correct position
                            for item in self.scene().items():
                                if isinstance(item, Rook) and item.getStartingGridPosition() == (7, 0) and item.first_move == True and item.color == self.color:
                                    item.setPos(5 * 80, new_grid_y * 80)
                                    item.updateBoardStatus()
                                    item.first_move = False
                                    self.chessboard.switchTurnsAndAddOneToTurnTimer()
                                    break
                            self.setPos((new_grid_x - 1) * 80, new_grid_y * 80)
                            self.updateBoardStatus()
                            self.first_move = False
<<<<<<< Updated upstream
                        elif self.chessboard.current_board_state[new_grid_y][new_grid_x - 1] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x - 2] != "Empty":
                            self.return_to_original_position()
=======
                            # zmiennaRobocza == True
                            
                        elif self.chessboard.current_board_state[new_grid_y][new_grid_x - 1] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x - 2] != "Empty":
                           self.return_to_original_position()
                           return
>>>>>>> Stashed changes
                    # for long castling
                    if new_grid_x == self.original_grid_x - 4 and new_grid_y == self.original_grid_y:
                        # Check if the squares between the king and rook are empty
                        if self.chessboard.current_board_state[new_grid_y][new_grid_x + 1] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 2] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 3] == "Empty":
                            # Check if the rook is in the correct position
                            for item in self.scene().items():
                                if isinstance(item, Rook) and item.getStartingGridPosition() == (0, 0) and item.first_move == True and item.color == self.color:
                                    item.setPos(3 * 80, new_grid_y * 80)
                                    item.updateBoardStatus()
                                    item.first_move = False
                                    self.chessboard.switchTurnsAndAddOneToTurnTimer()
                                    break
                            self.setPos((new_grid_x + 2) * 80, new_grid_y * 80)
                            self.updateBoardStatus()
                            self.first_move = False
<<<<<<< Updated upstream
                        elif self.chessboard.current_board_state[new_grid_y][new_grid_x + 1] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 2] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 3] != "Empty":
                            self.return_to_original_position()
=======
                            # zmiennaRobocza == True
                        elif self.chessboard.current_board_state[new_grid_y][new_grid_x + 1] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 2] != "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x + 3] != "Empty":
                            self.return_to_original_position()
                            return


        # if zmiennaRobocza == False: 
        #     super(King, self).mouseReleaseEvent(event)
        # elif zmiennaRobocza == True:
        #     return

>>>>>>> Stashed changes

if __name__ == '__main__':
    app = QApplication(sys.argv)
    chessboard = ChessBoard()
    window = MainWindow(chessboard)
    window.show()
    sys.exit(app.exec_())