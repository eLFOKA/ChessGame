import sys
from PyQt5.QtWidgets import QApplication, QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsItem
from PyQt5.QtSvg import QGraphicsSvgItem
from PyQt5.QtGui import QBrush, QColor, QTransform
from PyQt5.QtCore import Qt, QPointF

class ChessBoard(QGraphicsView):
    def __init__(self):
        super(ChessBoard, self).__init__()
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setSceneRect(0, 0, 640, 640)
        self.drawBoard()
        self.addPieces()
        self.current_turn = 'white'  # White starts the game
        self.current_board_state = [[0 for _ in range(8)] for _ in range(8)]
        self.turnTimer = 0
        self.setStartingboardState()

    # Method to switch turns
    def switchTurns(self):
        self.current_turn = 'black' if self.current_turn == 'white' else 'white'


    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)

    def addPieces(self):
        # Black pieces
        self.addPiece(Rook("pieces/black/brook.svg", 0, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 1, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 2, 0, 'black',self))
        self.addPiece(Queen("pieces/black/bqueen.svg", 3, 0, 'black',self))
        self.addPiece(King("pieces/black/bking.svg", 4, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 5, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 6, 0, 'black',self))
        self.addPiece(Rook("pieces/black/brook.svg", 7, 0, 'black',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/black/bpawn.svg", i, 1, 'black', self))
        
        # White pieces
        self.addPiece(Rook("pieces/white/wrook.svg", 0, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 1, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 2, 7, 'white',self))
        self.addPiece(Queen("pieces/white/wqueen.svg", 3, 7, 'white',self))
        self.addPiece(King("pieces/white/wking.svg", 4, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 5, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 6, 7, 'white',self))
        self.addPiece(Rook("pieces/white/wrook.svg", 7, 7, 'white',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/white/wpawn.svg", i, 6, 'white', self))

    def addPiece(self, piece):
        self.scene.addItem(piece)

    def setStartingboardState(self):

        # Empty spaces
        for i in range(2, 6):
            for j in range(8):
                self.current_board_state[i][j] = "Empty"

        for i in range(8):
            for j in range(2):
                if i == 0 and j == 4:
                    self.current_board_state[j][i] = "black_king"
                else:
                    self.current_board_state[j][i] = "black_piece"

        for i in range(8):
            for j in range(6, 8):
                if i == 7 and j == 4:
                    self.current_board_state[j][i] = "white_king"
                else:
                    self.current_board_state[j][i] = "white_piece"

    def getBoardState(self):
        return self.current_board_state

    

class ChessPiece(QGraphicsSvgItem):
    def __init__(self, image_path, x, y, color, chessboard):
        super(ChessPiece, self).__init__(image_path)
        self.setPos(x * 80, y * 80)
        self.default_scale = 1.8
        self.setScale(self.default_scale)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemIsSelectable)
        self.color = color
        self.chessboard = chessboard
        self.isKing = False
        self.valid_move = False
        self.direction = 1 if self.color == 'black' else -1

    def mousePressEvent(self, event):
        super(ChessPiece, self).mousePressEvent(event)

        # Store the current grid position when the mouse is pressed
        self.original_grid_x = int(self.x() / 80)
        self.original_grid_y = int(self.y() / 80)

        # Remove any existing move indicators from the scene
        for item in self.scene().items():
            if isinstance(item, QGraphicsRectItem) and item.brush().color() == QColor(0, 255, 0, 127):
                self.scene().removeItem(item)

    def validate_move(self):

        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        # Check bounds
        if not (0 <= new_grid_x <= 7 and 0 <= new_grid_y <= 7):
            self.return_to_original_position()
            return

        # checing condition if there is figure on the new position [exlcuding the case of pawn]
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":

            # cant move if there is friendly piece on the new position
            if self.color == 'black':
                if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_piece":
                    self.return_to_original_position()
                    return
                else:
                    self.valid_move = True
            elif self.color == 'white':
                if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_piece":
                    self.return_to_original_position()
                    return
                else:
                    self.valid_move = True

            # cannot move if there is a king piece in the new position
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_king" or self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_king":
                self.return_to_original_position()
                return



        # updating the board state and moving the piece if the move is valid
        if self.valid_move == True:
            self.cupture_piece()
            self.setPos(new_x, new_y)
            self.updateBoardStatus()
            self.chessboard.switchTurns()
            self.first_move = False

    def cupture_piece(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        # remove piece that is being taken by player
        for item in self.scene().items():
            if isinstance(item, ChessPiece) and item.x() == new_x and item.y() == new_y:
                self.scene().removeItem(item)
                break

    def return_to_original_position(self):
        self.setPos(self.original_grid_x * 80, self.original_grid_y * 80)

    def mouseReleaseEvent(self, event):
        super(ChessPiece, self).mouseReleaseEvent(event)

        self.validate_move()

        self.setScale(self.default_scale)
        
        # Remove any existing move indicators from the scene
        for item in self.scene().items():
            if isinstance(item, QGraphicsRectItem) and item.brush().color() == QColor(0, 255, 0, 127):
                self.scene().removeItem(item)

    def updateBoardStatus(self):

        # prevoius move of the piece
        prev_x = round(self.original_grid_x * 80)
        prev_y = round(self.original_grid_y * 80)

        prev_grid_x = int(prev_x / 80)
        prev_grid_y = int(prev_y / 80)

        self.chessboard.current_board_state[prev_grid_y][prev_grid_x] = "Empty"

        # current move of the piece
        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)

        if self.color == 'black':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_piece"
        elif self.color == 'white':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_piece"

        self.printCurrentBoardStateInTerminal()

    def calculate_position(self):

        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)


        return new_x, new_y, new_grid_x, new_grid_y
    
    def printCurrentBoardStateInTerminal(self):
        for row in self.chessboard.current_board_state:
            print(row)
        print('\n')

class Pawn(ChessPiece, QGraphicsSvgItem):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Pawn, self).__init__(image_path, x, y, color, chessboard)  # Corrected parameter passing
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def mousePressEvent(self, event):
        super(Pawn, self).mousePressEvent(event)  # Ensure the default behavior runs
        
        # Show possible moves
        move_1 = 1 if self.color == 'black' else -1
        rect1 = QGraphicsRectItem(80 * self.x() / 80, 80 * (self.y() / 80 + move_1), 80, 80)
        rect1.setBrush(QBrush(QColor(0, 255, 0, 127)))
        self.scene().addItem(rect1)

        # Show second move if it's the first move of the pawn
        if self.first_move:
            move_2 = 2 if self.color == 'black' else -2
            rect2 = QGraphicsRectItem(80 * self.x() / 80, 80 * (self.y() / 80 + move_2), 80, 80)
            rect2.setBrush(QBrush(QColor(0, 255, 0, 127)))
            self.scene().addItem(rect2)


    def validate_move(self):

        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        direction = 1 if self.color == 'black' else -1
        
        # check if the move is valid for pawn figure in first move
        if self.chessboard.current_turn == self.color:
            if new_grid_x == self.original_grid_x:
                if self.first_move and new_grid_y - self.original_grid_y == 2 * direction:
                    self.valid_move = True
                elif new_grid_y - self.original_grid_y == direction:
                    self.valid_move = True
        else:
            self.return_to_original_position()
            return

        # Only for Pawn figure, (if there is a figure in front of the pawn, it cannot move forward)
        if self.color == 'black':
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_piece":
                self.return_to_original_position()
                return
        elif self.color == 'white':
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_piece":
                self.return_to_original_position()
                return
        

        # if there is a enemy figure on oposite site of the pawn, it can move diagonally


        super(Pawn, self).validate_move()
    

class Rook(ChessPiece):
    def __init__(self, image_path, x, y, color, board):
        super(Rook, self).__init__(image_path, x, y, color, board)

    def mousePressEvent(self, event):
        # Logic for showing possible moves for a rook can be added here
        
        #show posible moves of rook in 4 directions with if statemanet that rect wont be painted outside of chessboard

        move_1 = 1
        rect1 = QGraphicsRectItem(80 * self.x() / 80, 80 * (self.y() / 80 + move_1), 80, 80)
        rect1.setBrush(QBrush(QColor(0, 255, 0, 127)))
        self.scene().addItem(rect1)
        
        
        self.setScale(self.default_scale * 1.1)
        super(Rook, self).mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        # You might add more complex move validation logic here later
        self.setScale(self.default_scale)
        super(Rook, self).mouseReleaseEvent(event)

class Knight(ChessPiece):
    def mouseReleaseEvent(self, event):
        # Knight logic: L-shaped moves
        x_diff = abs(self.x() - event.lastPos().x())
        y_diff = abs(self.y() - event.lastPos().y())
        if not ((x_diff == 160 and y_diff == 80) or (x_diff == 80 and y_diff == 160)):
            self.setPos(event.lastPos())
        else:
            self.setPos(round(self.x() / 80) * 80, round(self.y() / 80) * 80)
        super(Knight, self).mouseReleaseEvent(event)

class Bishop(ChessPiece):
    def mouseReleaseEvent(self, event):
        # Bishop logic: can move diagonally
        if abs(self.x() - event.lastPos().x()) != abs(self.y() - event.lastPos().y()):
            self.setPos(event.lastPos())
        else:
            self.setPos(round(self.x() / 80) * 80, round(self.y() / 80) * 80)
        super(Bishop, self).mouseReleaseEvent(event)

class Queen(ChessPiece):
    def mouseReleaseEvent(self, event):
        # Queen logic: combines rook and bishop
        if self.x() != event.lastPos().x() and self.y() != event.lastPos().y() and \
           abs(self.x() - event.lastPos().x()) != abs(self.y() - event.lastPos().y()):
            self.setPos(event.lastPos())
        else:
            self.setPos(round(self.x() / 80) * 80, round(self.y() / 80) * 80)
        super(Queen, self).mouseReleaseEvent(event)

class King(ChessPiece):
    def __init__(self, image_path, x, y, color, board):
        super(King, self).__init__(image_path, x, y, color, board)
        self.isKing = True

    def mouseReleaseEvent(self, event):
        # King logic: one square any direction
        if abs(self.x() - event.lastPos().x()) > 80 or abs(self.y() - event.lastPos().y()) > 80:
            self.setPos(event.lastPos())
        else:
            self.setPos(round(self.x() / 80) * 80, round(self.y() / 80) * 80)
        super(King, self).mouseReleaseEvent(event)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    board = ChessBoard()
    board.show()
    sys.exit(app.exec_())
