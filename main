# board in grid coordinates
# 0  1  2  ...
# 1
# 2
# ...

# numerical vs grid cordinates vs chess cordinates
# (for pawn x,y) 80, 160 -> 1, 2 -> b2

# communication protocol
# string = {name} {from x,y} {to x,y}
# example: {p} {1,2} {1,3}
# p - pawn, k-king, q-queen, r-rook, b-bishop, n-knight

#msg avaible in the connection
# waiting - waiting for the other player to connect
# connectionConfirmed - connection has been confirmed
# {name} {from x,y} {to x,y} - move notation

from PyQt5.QtWidgets import QApplication, QRadioButton, QGraphicsSceneMouseEvent, QMessageBox, QWidget, QMainWindow, QPushButton, QLabel,  QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsItem, QLineEdit, QTextEdit
from PyQt5.QtSvg import QGraphicsSvgItem
from PyQt5.QtGui import QBrush, QColor, QFont, QKeyEvent, QTextOption
from PyQt5.QtCore import QObject, Qt, QThread, pyqtSignal
import numpy as np
import sqlite3
import sys
import xml.etree.ElementTree as ET
import json

import time   
# importuj biblioteki które są koniecznie do komunikacji sieciowej
import socket
import select

# Global variables
# Variables that are used across multiple functions
ProgramName = "Chess Game by Maksymilian Anzulewicz Beta 0.2"


class connection(QThread):
    signal = pyqtSignal(str)
    signalMsg = pyqtSignal(str)
    def __init__(self, presenter):
        super().__init__()
        self.presenter = presenter
        self.server = None
        self.client = None
        self.conn = None
        self.addr = None
        self.port = None
        self.ip = None
        self.isServer = False
        self.isClient = False
    
    def run(self):
        while True:
            if self.isServer:
                if self.conn == None:
                    self.conn, self.addr = self.server.accept()
                dataFromClient = self.receive()
                dataFromClient = dataFromClient.decode('utf-8')

                print(dataFromClient)
                if len(dataFromClient) == 5:
                    self.presenter.summarizeOtherPlayeMove(dataFromClient)
                elif dataFromClient == 'waiting':
                    self.presenter.connectionHandling("waiting", "server")
                    self.send("connectionConfirmed")
                # jeśli 3 pierwsze litery wiadomości to msg to znaczy że to wiadomość od drugiego gracza
                elif dataFromClient.find('msg') != -1:
                    self.signalMsg.emit(dataFromClient)
                dataFromClient = None
            
            
            elif self.isClient:
                dataFromServer = self.receive()
                dataFromServer = dataFromServer.decode('utf-8') 
                
                print(dataFromServer)
                if len(dataFromServer) == 5:
                    self.presenter.summarizeOtherPlayeMove(dataFromServer)
                elif dataFromServer == 'connectionConfirmed':
                    self.presenter.connectionHandling("connectionConfirmed", "client")
                elif dataFromServer == '10minutes':
                    self.presenter.time = 600
                elif dataFromServer == '1minute':
                    self.presenter.time = 60
                elif dataFromServer == 'gameStarted':
                    self.signal.emit("Multiplayer")
                # jeśli wiadomość zawiera msg w środku to znaczy że to wiadomość od drugiego gracza
                elif dataFromServer.find('msg') != -1:
                    self.signalMsg.emit(dataFromServer)

                dataFromServer = None

            time.sleep(1)
    def createServer(self, port):
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind(('localhost', port))
        self.server.listen(10)
        self.isServer = True
        self.isClient = False
        self.port = port
    def joinServer(self, ip, port):
        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.client.connect((ip, port))
        self.ip = ip
        self.port = port
        self.isClient = True
        self.isServer = False
    def closeConnection(self):
        if self.isServer:
            self.conn.close()
            self.server.close()
            print("Server has been closed")
        elif self.isClient:
            self.client.close()
            print("Client has been closed")
        self.isServer = False
        self.isClient = False   
    def send(self, data):
        if self.isServer:
            self.conn.send(data.encode('utf-8'))
        elif self.isClient:
            self.client.send(data.encode('utf-8'))   
    def receive(self):
        if self.isServer:
            return self.conn.recv(1024)
        elif self.isClient:
            return self.client.recv(1024)

class ClockThread(QThread):
    def __init__(self, timeAmount, presenter):
        super().__init__()
        self.presenter = presenter
        self.witchPlayer = 'white'
        self.TimeAmountWhite = timeAmount
        self.TimeAmountBlack = timeAmount

    def run(self):
        while True:
            time.sleep(1)
            if self.witchPlayer == 'white':
                self.TimeAmountWhite -= 1
                self.presenter.win.updateLabelWhiteTime(self.convertTimeToString(self.TimeAmountWhite))
                self.presenter.win.scene.update()
            elif self.witchPlayer == 'black':
                self.TimeAmountBlack -= 1
                self.presenter.win.updateLabelBlackTime(self.convertTimeToString(self.TimeAmountBlack))
                self.presenter.win.scene.update()
    
    def set(self, timeAmount):
        self.TimeAmountWhite = timeAmount
        self.TimeAmountBlack = timeAmount

    def convertTimeToString(self, timeAmount):
        minutes = timeAmount // 60
        seconds = timeAmount % 60
        return f"{minutes:02}:{seconds:02}"

    def switchPlayer(self):
        if self.witchPlayer == 'white':
            self.witchPlayer = 'black'
        elif self.witchPlayer == 'black':
            self.witchPlayer = 'white'

class model():
    def __init__(self, presenter):
        super(model, self).__init__()
        self.presenter = presenter
        # create empty 2d array with 8x8 dimensions
        self.currentBoardState = [[0 for _ in range(8)] for _ in range(8)]
        
        self.initCurrentBoardState()

    def canMove(self, name, prevX, prevY, x, y, color, hasMoved):
        # all cordinates here are in grid cordinates
        ### checking only if the move is possible then return True otherwise False
        
        # color in this method is the color of the player that is moving the piece

        # checking if the move is possible
        
        if self.currentBoardState[y][x] != 'empty':
            # take only 5 first letters of self.currentBoardState[y][x] to get the color of the field so if there is string like 'whitepawn' it will take only 'white'
            colorOfDestinationField = self.currentBoardState[y][x][0:5]         
        else:
            colorOfDestinationField = 'empty'
        
        
        # na czas oddania
        ##################################################################################
        # beginnig with rules that aplly to all figures (rules that reject the move)
        if colorOfDestinationField == color and colorOfDestinationField != 'empty':
            return False
        elif (x < 0 | x > 8 ) or (y < 0 | y > 8):
            return False
        elif color != self.presenter.currentPlayer:
            return False
        
        # rules that apply to specific figures
        if name == 'pawn':

            # if its first move pawn can move 2 fields forward
            if hasMoved == False:
                # for white player
                if color == 'white' and self.currentBoardState[y][x] == 'empty' and self.currentBoardState[y - 1][x] == 'empty':
                    if x == prevX and prevY == y - 2:
                        return True
                elif color == 'black' and self.currentBoardState[y][x] == 'empty' and self.currentBoardState[y + 1][x] == 'empty':    
                    # for black player
                    if x == prevX and prevY == y + 2:
                        return True
            
            # Pawn can move one field forward if the field is empty
            if color == 'white' and self.currentBoardState[y][x] == 'empty':
                if x == prevX and prevY == y - 1:
                    return True
            elif color == 'black' and self.currentBoardState[y][x] == 'empty':
                if x == prevX and prevY == y + 1:
                    return True
                
            # Pawn can move diagonally and capture a enemy piece if there is one
            if color == 'white' and self.currentBoardState[y][x] != 'empty' and colorOfDestinationField == 'black':
                if (x == prevX + 1 or x == prevX - 1) and y == prevY + 1:
                    return True
            elif color == 'black' and self.currentBoardState[y][x] != 'empty' and colorOfDestinationField == 'white':
                if (x == prevX + 1 or x == prevX - 1) and y == prevY - 1:
                    return True
        elif name == 'rook':
            # rook mechanics
            # rook can move only in vertical or horizontal direction
            if x == prevX:
                # moving up
                if y < prevY:
                    for i in range(prevY - 1, y, -1):
                        if self.currentBoardState[i][x] != 'empty':
                            return False
                    return True
                # moving down
                elif y > prevY:
                    for i in range(prevY + 1, y):
                        if self.currentBoardState[i][x] != 'empty':
                            return False
                    return True
            elif y == prevY:
                # moving left
                if x < prevX:
                    for i in range(prevX - 1, x, -1):
                        if self.currentBoardState[y][i] != 'empty':
                            return False
                    return True
                # moving right
                elif x > prevX:
                    for i in range(prevX + 1, x):
                        if self.currentBoardState[y][i] != 'empty':
                            return False
                    return True
        elif name == 'knight':
            if (x == prevX + 1 and y == prevY + 2) or (x == prevX - 1 and y == prevY + 2) or (x == prevX + 1 and y == prevY - 2) or (x == prevX - 1 and y == prevY - 2) or (x == prevX + 2 and y == prevY + 1) or (x == prevX - 2 and y == prevY + 1) or (x == prevX + 2 and y == prevY - 1) or (x == prevX - 2 and y == prevY - 1):
                return True
        elif name == 'bishop':
            if abs(x - prevX) == abs(y - prevY):
                # moving up right
                if x > prevX and y < prevY:
                    for i in range(1, abs(x - prevX)):
                        if self.currentBoardState[prevY - i][prevX + i] != 'empty':
                            return False
                    return True
                # moving up left
                elif x < prevX and y < prevY:
                    for i in range(1, abs(x - prevX)):
                        if self.currentBoardState[prevY - i][prevX - i] != 'empty':
                            return False
                    return True
                # moving down right
                elif x > prevX and y > prevY:
                    for i in range(1, abs(x - prevX)):
                        if self.currentBoardState[prevY + i][prevX + i] != 'empty':
                            return False
                    return True
                # moving down left
                elif x < prevX and y > prevY:
                    for i in range(1, abs(x - prevX)):
                        if self.currentBoardState[prevY + i][prevX - i] != 'empty':
                            return False
                    return True
        elif name == 'queen':
            if abs(x - prevX) == abs(y - prevY):
                # moving up right
                if x > prevX and y < prevY:
                    for i in range(1, abs(x - prevX)):
                        if self.currentBoardState[prevY - i][prevX + i] != 'empty':
                            return False
                    return True
                # moving up left
                elif x < prevX and y < prevY:
                    for i in range(1, abs(x - prevX)):
                        if self.currentBoardState[prevY - i][prevX - i] != 'empty':
                            return False
                    return True
                # moving down right
                elif x > prevX and y > prevY:
                    for i in range(1, abs(x - prevX)):
                        if self.currentBoardState[prevY + i][prevX + i] != 'empty':
                            return False
                    return True
                # moving down left
                elif x < prevX and y > prevY:
                    for i in range(1, abs(x - prevX)):
                        if self.currentBoardState[prevY + i][prevX - i] != 'empty':
                            return False
                    return True
            elif x == prevX:
                # moving up
                if y < prevY:
                    for i in range(prevY - 1, y, -1):
                        if self.currentBoardState[i][x] != 'empty':
                            return False
                    return True
                # moving down
                elif y > prevY:
                    for i in range(prevY + 1, y):
                        if self.currentBoardState[i][x] != 'empty':
                            return False
                    return True
            elif y == prevY:
                # moving left
                if x < prevX:
                    for i in range(prevX - 1, x, -1):
                        if self.currentBoardState[y][i] != 'empty':
                            return False
                    return True
                # moving right
                elif x > prevX:
                    for i in range(prevX + 1, x):
                        if self.currentBoardState[y][i] != 'empty':
                            return False
                    return True
        elif name == 'king':
            if abs(x - prevX) == 1 and abs(y - prevY) == 1:
                return True
            elif abs(x - prevX) == 1 and y == prevY:
                return True
            elif abs(y - prevY) == 1 and x == prevX:
                return True
         
        ##################################################################################





        return False
    
    def updateBoardState(self, name, prevX, prevY, x, y, color):
        # all cordinates here are in grid cordinates
        self.currentBoardState[y][x] = color + name
        self.currentBoardState[prevY][prevX] = 'empty'
    
    def initCurrentBoardState(self):
        for i in range(8):
            self.currentBoardState[1][i] = 'whitepawn'
            self.currentBoardState[6][i] = 'blackpawn'
        self.currentBoardState[0][0] = 'whiterook'
        self.currentBoardState[0][7] = 'whiterook'
        self.currentBoardState[7][0] = 'blackrook'
        self.currentBoardState[7][7] = 'blackrook'
        self.currentBoardState[0][1] = 'whiteknight'
        self.currentBoardState[0][6] = 'whiteknight'
        self.currentBoardState[7][1] = 'blackknight'
        self.currentBoardState[7][6] = 'blackknight'
        self.currentBoardState[0][2] = 'whitebishop'
        self.currentBoardState[0][5] = 'whitebishop'
        self.currentBoardState[7][2] = 'blackbishop'
        self.currentBoardState[7][5] = 'blackbishop'
        self.currentBoardState[0][3] = 'whitequeen'
        self.currentBoardState[7][3] = 'blackqueen'
        self.currentBoardState[0][4] = 'whiteking'
        self.currentBoardState[7][4] = 'blackking'

        for i in range(8):
            for j in range(8):
                if self.currentBoardState[i][j] == 0:
                    self.currentBoardState[i][j] = 'empty'

    # Bot methods
    def findBestMoveForBot(self):

        # iterate over all figures and check if the piece can capture enemy piece
        for i in range(8):
            for j in range(8):
                if self.currentBoardState[i][j][0:5] == 'black':
                    figureName = self.currentBoardState[i][j][5:]
                    
                    # iterate over all fields and check if the piece can capture enemy piece
                    for k in range(8):
                        for l in range(8):
                            if self.currentBoardState[k][l][0:5] == 'white':
                                if self.canMove(figureName, j, i, l, k, 'black', False):
                                    return figureName, l, k, j, i
                    
                    # if there is no enemy piece to capture then move the piece to random field
                    # make random move
                    for k in range(8):
                        for l in range(8):
                            if self.canMove(figureName, j, i, l, k, 'black', False):
                                return figureName, l, k, j, i
        
     
        


    # debuggin methods
    def printCurrentBoardState(self):
        for i in range(8):
            print(self.currentBoardState[i])


class MainWindow(QMainWindow):

    def __init__(self, presenter):
        super(MainWindow, self).__init__()
        self.presenter = presenter
        # variable containing the screen resolution of the user
        self.ScrResWidtth, self.ScrResHeight = self.getUserScreenResolution()

        self.initConfigUI()

    # initUI methods
    # Methods that initialize the user interface
    def initMainUI(self):
        self.close()
        self.setWindowTitle(ProgramName)
        self.setFixedSize(900, 692)

        # creating scene and view for chess board
        self.scene = QGraphicsScene(self)
        self.scene.setSceneRect(0, 0, 640, 640)
        self.view = QGraphicsView(self)
        self.view.setGeometry(0, 50, 642, 642)
        self.view.setScene(self.scene)

        self.drawBoard()
        self.addPieces()

        self.createTextField2(652, 200, 240, 485)
        self.createLabelCurrentPlayerTurn(660, 15, 250, 25, "White player turn")
        self.createLabelIsThereCheck(660, 50, 250, 25, "No check")
        self.createLabelWhiteTime(95, 11, 82, 20, "10:00")
        self.createLabelWhiteTimeText(10, 10, 80, 20, "White:")
        self.createLabelBlackTime(565, 11, 82, 20, "10:00")
        self.createLabelBlackTimeText(485, 10, 80, 20, "Black:")

        # communications with other player
        self.createTextLabelCommunicationWithOtherPlayer(660, 100, 200, 25, "")


        self.deleteAllButtonsFromInitConfigUI()
        self.show()
    def initConfigUI(self):
        self.setWindowTitle(ProgramName)
        winHeight = round(self.ScrResHeight / 2)
        winWidth = round(self.ScrResWidtth / 3)

        controlsWidth = round((winHeight / 2) - 10)
        controlsHeight = 10
        self.setFixedSize(winWidth, winHeight)

        self.createRadioButtons(controlsWidth, controlsHeight + 100, 20, 20)
        self.createLabelsForRadioButtons(controlsWidth + 20, controlsHeight + 100, 120, 20, "AI bot", "Player same PC", "Multiplayer")
        
        self.createButtonsForHostorJoin(controlsWidth, controlsHeight + 200)
        self.createTextBoxesForIPandPort(controlsWidth, controlsHeight + 250, 120, 20)
        self.createLabelsForIPandPort(controlsWidth + 125, controlsHeight + 250, 80, 20, "IP", "Port")
        
        self.createLabelConnectionStatus(controlsWidth, controlsHeight + 350, 200, 40, "Connection status: Not connected")
        self.createButtonJoinServer(controlsWidth, controlsHeight + 300, "Join server")
        self.createButtonCreateServer(controlsWidth, controlsHeight + 300, "Create server")

        self.createButtonTime1(controlsWidth + 150, controlsHeight + 180, "10 minutes")
        self.createButtonTime2(controlsWidth + 150, controlsHeight + 210, "1 minute") 
        self.createLabelTimeSettings(controlsWidth + 150, controlsHeight + 160, 100, 20, "Choose time")

        self.createButtonConfigAccept(controlsWidth, controlsHeight + 400, 100, 30, "Start game")

        self.hideAcceptButton()
        self.hideMultiplayerSettings()
        self.hideTimeSettings()

        self.show()

    # createWidget methods
    # Methods that create widgets
    def createButtonSTART(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onButtonClickSTART)
        button.resize(100, 30)
    def createButton(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onButtonClick2)
        button.resize(100, 30)
    def createButtonTime1(self, x, y, text):
        self.buttonTime1 = QPushButton(text, self)
        self.buttonTime1.move(x, y)
        self.buttonTime1.clicked.connect(self.onTimeButtonClick1)
        self.buttonTime1.resize(100, 30)
    def createButtonTime2(self, x, y, text):
        self.buttonTime2 = QPushButton(text, self)
        self.buttonTime2.move(x, y)
        self.buttonTime2.clicked.connect(self.onTimeButtonClick2)
        self.buttonTime2.resize(100, 30)
    def createWindowContainer(self, x, y, width, height, text):
        self.windowContainer = QWidget(self)
        self.windowContainer.setGeometry(x, y, width, height)
        self.windowContainer.setWindowTitle(text)
    def createlabel(self, x, y, width, height, text, font_size = 10):
        self.label = QLabel(self)
        self.label.setText(text)
        self.label.move(x, y) 
        self.label.resize(width, height)
        self.label.setFont(QFont("Arial", font_size))
    def createTextField(self, x, y, width, height):
        self.text_field = QLineEdit(self)
        self.text_field.move(x, y)
        self.text_field.resize(width, height)
    def createTextField2(self, x, y, width, height):
        self.text_field2 = QTextEdit(self)
        self.text_field2.move(x, y)
        self.text_field2.resize(width, height)
        self.text_field2.setReadOnly(True)
        self.text_field2.setAlignment(Qt.AlignTop)
        self.text_field2.setWordWrapMode(QTextOption.WordWrap)
    def createRadioButtons(self, x, y, width, height):
        self.radioButtonAIbot = QRadioButton(self)
        self.radioButtonAIbot.move(x, y)
        self.radioButtonAIbot.resize(width, height)
        self.radioButtonAIbot.clicked.connect(self.onRadioButtonAIbot)

        self.radioButtonPlayerSamePC = QRadioButton(self)
        self.radioButtonPlayerSamePC.move(x, y + 30)
        self.radioButtonPlayerSamePC.resize(width, height)
        self.radioButtonPlayerSamePC.clicked.connect(self.onRadioButtonPlayerSamePC)

        self.radiobuttonMultiplayer = QRadioButton(self)
        self.radiobuttonMultiplayer.move(x, y + 60)
        self.radiobuttonMultiplayer.resize(width, height)
        self.radiobuttonMultiplayer.clicked.connect(self.onRadioButtonMultiplayer)
    def createLabelsForRadioButtons(self, x, y, width, height, text1, text2, text3):
        self.labelAIbot = QLabel(self)
        self.labelAIbot.setText(text1)
        self.labelAIbot.move(x, y)
        self.labelAIbot.resize(width, height)

        self.labelPlayerSamePC = QLabel(self)
        self.labelPlayerSamePC.setText(text2)
        self.labelPlayerSamePC.move(x, y + 30)
        self.labelPlayerSamePC.resize(width, height)

        self.labelMultiplayer = QLabel(self)
        self.labelMultiplayer.setText(text3)
        self.labelMultiplayer.move(x, y + 60)
        self.labelMultiplayer.resize(width, height)
    def createTextBoxesForIPandPort(self, x, y, width, height):
        self.textBoxIP = QLineEdit(self)
        self.textBoxIP.move(x, y)
        self.textBoxIP.resize(width, height)

        self.textBoxPort = QLineEdit(self)
        self.textBoxPort.move(x, y + 25)
        self.textBoxPort.resize(width, height)
    def createLabelsForIPandPort(self, x, y, width, height, text1, text2):
        self.labelIP = QLabel(self)
        self.labelIP.setText(text1)
        self.labelIP.move(x, y)
        self.labelIP.resize(width, height)

        self.labelPort = QLabel(self)
        self.labelPort.setText(text2)
        self.labelPort.move(x, y + 25)
        self.labelPort.resize(width, height)
    def createButtonForPlayingWithAnotherPlayer(self, x, y, text):
        button = QPushButton(text, self)
        button.move(x, y)
        button.clicked.connect(self.onButtonClick2)
        button.resize(100, 30)
    def createButtonConfigAccept(self, x, y, width, height, text):
        self.buttonAccept = QPushButton(text, self)
        self.buttonAccept.move(x, y)
        self.buttonAccept.clicked.connect(self.onButtonConifgAccept)
        self.buttonAccept.resize(width, height)
    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        # draw board wth 8x8 squares light and dark colors and add it to scene plus move y by 50 to make space for buttons
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)
    def createButtonsForHostorJoin(self, x, y):
        self.buttonHost = QPushButton("Host", self)
        self.buttonHost.move(x, y)
        self.buttonHost.clicked.connect(self.onButtonHost)
        self.buttonHost.resize(50, 30)

        self.buttonJoin = QPushButton("Join", self)
        self.buttonJoin.move(x + 52, y)
        self.buttonJoin.clicked.connect(self.onButtonJoin)
        self.buttonJoin.resize(50, 30)
    def createLabelCurrentPlayerTurn(self, x, y, width, height, text):
        self.labelCurrentPlayerTurn = QLabel(self)
        self.labelCurrentPlayerTurn.setText(text)
        self.labelCurrentPlayerTurn.move(x, y)
        self.labelCurrentPlayerTurn.resize(width, height)
        self.labelCurrentPlayerTurn.setFont(QFont("Arial", 14))
        self.labelCurrentPlayerTurn.setStyleSheet("color: Blue; font-weight: bold;")
    def createLabelWhiteTime(self, x, y, width, height, text):
        self.labelWhiteTime = QLabel(self)
        self.labelWhiteTime.setText(text)
        self.labelWhiteTime.move(x, y)
        self.labelWhiteTime.resize(width, height)
        self.labelWhiteTime.setFont(QFont("Arial", 16))
    def createLabelBlackTime(self, x, y, width, height, text):
        self.labelBlackTime = QLabel(self)
        self.labelBlackTime.setText(text)
        self.labelBlackTime.move(x, y)
        self.labelBlackTime.resize(width, height)
        self.labelBlackTime.setFont(QFont("Arial", 16))
    def createLabelWhiteTimeText(self, x, y, width, height, text):
        self.labelWhiteTimeText = QLabel(self)
        self.labelWhiteTimeText.setText(text)
        self.labelWhiteTimeText.move(x, y)
        self.labelWhiteTimeText.resize(width, height)
        self.labelWhiteTimeText.setFont(QFont("Arial", 16))
    def createLabelBlackTimeText(self, x, y, width, height, text):
        self.labelBlackTimeText = QLabel(self)
        self.labelBlackTimeText.setText(text)
        self.labelBlackTimeText.move(x, y)
        self.labelBlackTimeText.resize(width, height)
        self.labelBlackTimeText.setFont(QFont("Arial", 16))
    def createLabelIsThereCheck(self, x, y, width, height, text):
        self.labelIsThereCheck = QLabel(self)
        self.labelIsThereCheck.setText(text)
        self.labelIsThereCheck.move(x, y)
        self.labelIsThereCheck.resize(width, height)
        self.labelIsThereCheck.setFont(QFont("Arial", 14))
    def createButtonCreateServer(self, x, y, text):
        self.buttonServer = QPushButton(text, self)
        self.buttonServer.move(x, y)
        self.buttonServer.clicked.connect(self.onButtonCreateServer)
        self.buttonServer.resize(100, 30)
    def createLabelConnectionStatus(self, x, y, width, height, text):
        self.labelConnectionStatus = QLabel(self)
        self.labelConnectionStatus.setText(text)
        self.labelConnectionStatus.move(x, y)
        self.labelConnectionStatus.resize(width, height)
        self.labelConnectionStatus.setFont(QFont("Arial", 8))
        self.labelConnectionStatus.setWordWrap(True)
    def createButtonJoinServer(self, x, y, text):
        self.buttonJoinServer = QPushButton(text, self)
        self.buttonJoinServer.move(x, y)
        self.buttonJoinServer.clicked.connect(self.onButtonJoinServer)
        self.buttonJoinServer.resize(100, 30)
    def createLabelTimeSettings(self, x, y, width, height, text):
        self.labelTimeSettings = QLabel(self)
        self.labelTimeSettings.setText(text)
        self.labelTimeSettings.move(x, y)
        self.labelTimeSettings.resize(width, height)
        self.labelTimeSettings.setFont(QFont("Arial", 8))
    def createTextLabelCommunicationWithOtherPlayer(self, x, y, width, height, text):
        self.labelCommunicationWithOtherPlayer = QTextEdit(self)
        self.labelCommunicationWithOtherPlayer.setText(text)
        self.labelCommunicationWithOtherPlayer.move(x, y)
        self.labelCommunicationWithOtherPlayer.resize(width, height)
        self.labelCommunicationWithOtherPlayer.setFont(QFont("Arial", 8))

    # info windows methods
    def createInfoWindow(self, text):
        QMessageBox.about(self, "Info", text)
        # set messagebox focus only
        
    # Widget event methods
    # Methods that handle widget events
    def onTimeButtonClick1(self):
        self.presenter.time = 600
        self.writeTextToLabelTimeSettings("10 minutes")
        self.presenter.send("10minutes")
    def onTimeButtonClick2(self):
        self.presenter.time = 60
        self.writeTextToLabelTimeSettings("1 minute")
        self.presenter.send("1minute")
    def onButtonClickSTART(self):
        self.presenter.gameStarted = True
        self.presenter.clk.start()
        # self.model.gameStarted = True
        # self.Clock.start()
        # print("Game has started")
        return
    def onButtonClick2(self):
        self.presenter.clk.start()
    def updateMoveLog(self, move_notation):
        # Method to update the QTextEdit or QLineEdit with the move notation
        current_text = self.text_field2.toPlainText()
        new_text = f"{current_text}\n{move_notation}"  # Append the new move
        self.text_field2.setText(new_text)  # For QLineEdit
        # If you're using QTextEdit, you might prefer: self.text_field2.append(move_notation)
    def updateLabel(self, text):
        self.label.setText(text)
    def updateTextField2(self, text):
        # if self.insideTimer == 0:
        #     return
        # else:
        #     text = self.model.returnFigurePositionToChessCordinates(self.model.last_moved_piece)
        #     self.text_field2.setText(text)
        #     self.insideTimer += 1
        return
    def readTextField(self):
        text = self.text_field.text()
        return text
    def readIP(self):
        text = self.textBoxIP.text()
        return text
    def readPort(self):
        text = self.textBoxPort.text()
        return text
    def readRadioButton(self):
        playerchoice = ""
        if self.radioButtonAIbot.isChecked():
            playerchoice = "AI bot"
        elif self.radioButtonPlayerSamePC.isChecked():
            playerchoice = "Player same PC"
        elif self.radiobuttonMultiplayer.isChecked():
            playerchoice = "Multiplayer"

        return playerchoice
    def onButtonConifgAccept(self):
        self.presenter.startGame(self.readRadioButton())
        self.initMainUI()

    def onButtonHost(self):
        self.showHostServerSettings()
        self.presenter.iswho = "server"
        self.showTimeSettings()
    def onButtonJoin(self):
        self.showClientServerSettings()
        self.hideTimeSettings()
        self.presenter.iswho = "client"
    def updateLabelCurrentPlayerTurn(self, text):
        if text == 'white':
            self.labelCurrentPlayerTurn.setText("White player turn")
        elif text == 'black':
            self.labelCurrentPlayerTurn.setText("Black player turn")
    def onRadioButtonMultiplayer(self):
        if self.radiobuttonMultiplayer.isChecked():
            self.hideAcceptButton()
            self.showMultiplayerButtons()
    def onRadioButtonAIbot(self):
        if self.radioButtonAIbot.isChecked():
            self.hideMultiplayerSettings()
            self.hideAcceptButton()
            QMessageBox.about(self, "Info", "AI bot mode is not available yet")         
    def onRadioButtonPlayerSamePC(self):
        # jeśli wciśnięty pokaż accpet button jeśli nie to schowaj
        if self.radioButtonPlayerSamePC.isChecked() and self.radioButtonAIbot.isChecked() == False and self.radiobuttonMultiplayer.isChecked() == False:
            self.hideMultiplayerSettings()
            self.showAcceptButton()
            self.showTimeSettings()
    def onButtonCreateServer(self):
        QMessageBox.about(self, "Info", f"Server has been created on port {self.readPort()} and your IP is {self.readIP()} wait for connection from other player")
        self.presenter.createServer(int(self.readPort()))
    def writeTextToLabelConnectionStatus(self, text):
        self.labelConnectionStatus.setText(text)
    def onButtonJoinServer(self):
        ip = self.readIP()
        port = self.readPort()
        self.presenter.joinServer(ip, int(port))
        self.labelConnectionStatus.setText("Connection status: waitng for server confirmation")
    def writeTextToLabelTimeSettings(self, text):
        self.labelTimeSettings.setText(text)

    def updateLabelWhiteTime(self, text):
        self.labelWhiteTime.setText(text)
    def updateLabelBlackTime(self, text):
        self.labelBlackTime.setText(text)
    def readCommunicationWithOtherPlayer(self):
        return self.labelCommunicationWithOtherPlayer.toPlainText()
    def writeCommunicationWithOtherPlayer(self, text):
        # dodaj text do tego co jest już w polu
        self.text_field2.setText(text)


    
    # Widget visibility methods
    def hideAcceptButton(self):
        self.buttonAccept.hide()
    def showAcceptButton(self):
        self.buttonAccept.show()
    def hideMultiplayerSettings(self):
        self.buttonHost.hide()
        self.buttonJoin.hide()
        self.labelIP.hide()
        self.labelPort.hide()
        self.textBoxIP.hide()
        self.textBoxPort.hide()
        self.buttonServer.hide()
        self.labelConnectionStatus.hide()
        self.buttonJoinServer.hide()
    def showMultiplayerButtons(self):
        self.buttonHost.show()
        self.buttonJoin.show()
    def showHostServerSettings(self):
        self.labelIP.show()
        self.labelPort.show()
        self.buttonServer.show()
        self.textBoxIP.show()
        self.textBoxPort.show()
        self.labelConnectionStatus.show()
    def showClientServerSettings(self):
        self.labelIP.show()
        self.labelPort.show()
        self.textBoxIP.show()
        self.textBoxPort.show()
        self.labelConnectionStatus.show()
        self.buttonJoinServer.show()
    def hideTimeSettings(self):
        self.labelTimeSettings.hide()
        self.buttonTime1.hide()
        self.buttonTime2.hide()
    def showTimeSettings(self):
        self.labelTimeSettings.show()
        self.buttonTime1.show()
        self.buttonTime2.show()  
    def deleteAllButtonsFromInitConfigUI(self):
        self.buttonHost.hide()
        self.buttonJoin.hide()
        self.buttonServer.hide()
        self.buttonJoinServer.hide()
        self.buttonTime1.hide()
        self.buttonTime2.hide()
        self.buttonAccept.hide()
        self.radioButtonAIbot.hide()
        self.radioButtonPlayerSamePC.hide()
        self.radiobuttonMultiplayer.hide()

    # Utility methods
    # Methods that perform utility functions
    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)
    def addPieces(self):
        for i in range(8):
            self.scene.addItem(ChessPiece("pieces/white/wpawn.svg", 80 * i, 80, 'white', 'pawn', self))
            self.scene.addItem(ChessPiece("pieces/black/bpawn.svg", 80 * i, 480 , 'black', 'pawn', self))

        self.scene.addItem(ChessPiece("pieces/white/wrook.svg", 0, 0, 'white', 'rook', self))
        self.scene.addItem(ChessPiece("pieces/white/wrook.svg", 560, 0, 'white', 'rook', self))
        self.scene.addItem(ChessPiece("pieces/black/brook.svg", 0, 560, 'black', 'rook', self))
        self.scene.addItem(ChessPiece("pieces/black/brook.svg", 560, 560, 'black', 'rook', self))
        self.scene.addItem(ChessPiece("pieces/white/wknight.svg", 80, 0, 'white', 'knight', self))
        self.scene.addItem(ChessPiece("pieces/white/wknight.svg", 480, 0, 'white', 'knight', self))
        self.scene.addItem(ChessPiece("pieces/black/bknight.svg", 80, 560, 'black', 'knight', self))
        self.scene.addItem(ChessPiece("pieces/black/bknight.svg", 480, 560, 'black', 'knight', self))
        self.scene.addItem(ChessPiece("pieces/white/wbishop.svg", 160, 0, 'white', 'bishop', self))
        self.scene.addItem(ChessPiece("pieces/white/wbishop.svg", 400, 0, 'white', 'bishop', self))
        self.scene.addItem(ChessPiece("pieces/black/bbishop.svg", 160, 560, 'black', 'bishop', self))
        self.scene.addItem(ChessPiece("pieces/black/bbishop.svg", 400, 560, 'black', 'bishop', self))
        self.scene.addItem(ChessPiece("pieces/white/wqueen.svg", 240, 0, 'white', 'queen', self))
        self.scene.addItem(ChessPiece("pieces/black/bqueen.svg", 240, 560, 'black', 'queen', self))
        self.scene.addItem(ChessPiece("pieces/white/wking.svg", 320, 0, 'white', 'king', self))
        self.scene.addItem(ChessPiece("pieces/black/bking.svg", 320, 560, 'black', 'king', self))
    def keyPressEvent(self, event: QKeyEvent) -> None:
        if event.key() == Qt.Key_Escape:
            self.close()
        elif event.key() == Qt.Key_W:
            msg = self.readCommunicationWithOtherPlayer()
            self.writeCommunicationWithOtherPlayer("")
            self.presenter.send(f"msg{msg}")
        elif event.key() == Qt.Key_P:
            for item in self.scene.items():
                if isinstance(item, ChessPiece):
                    if item.color == 'black' and item.Name == 'pawn':
                        print(f'{item.getPreviousPosition()} from {item.color}')

        super().keyPressEvent(event)
    def deleteAllPieces(self):
        for item in self.scene.items():
            if isinstance(item, ChessPiece):
                self.scene.removeItem(item)
    def movePieceFromInsideProgram(self, prevX, prevY, x, y):
        # search for the piece position
        for item in self.scene.items():
            if isinstance(item, ChessPiece):
                if item.getPreviousPosition() == (prevX, prevY):
                    item.setPos(x * 80, y * 80)
    def removePieceFromBoard(self, x, y):
        for item in self.scene.items():
            if isinstance(item, ChessPiece):
                if item.Name == 'pawn' and item.color == 'black':
                    print(f'{item.getPreviousPosition()} from {item.color}')
                
                if item.getPreviousPosition() == (x, y):
                    self.scene.removeItem(item)


    def getUserScreenResolution(self):
        return QApplication.desktop().screenGeometry().width(), QApplication.desktop().screenGeometry().height()


class Presenter():
    def __init__(self):
        # game mechanics Variables
        self.gameStarted = True
        self.currentPlayer = 'white'
        self.time = None
        self.HumanPlayer = None

        self.clk = ClockThread(0, self)
        self.model = model(self)
        self.win = MainWindow(self)
        self.connection = connection(self)

        self.moves_history = []
        #only for lab 6...
        self.moves_history_from_where = []

        # multiplayer configuration variables
        self.iswho = None

        self.connection.signal.connect(self.startGameSlot)
        self.connection.signalMsg.connect(self.reciveMsgFromOtherPlayer)

        self.createSQLbaseForMovesHistory()

    # convertion methods
    def convertNumericalToGridCordinates(self, x, y):
        return x / 80, y / 80
    def convertGridToChessCordinates(self, x, y, name):
        if name == 'rook':
            charachter = 'R'
        elif name == 'knight':
            charachter = 'N'
        elif name == 'bishop':
            charachter = 'B'
        elif name == 'queen':
            charachter = 'Q'
        elif name == 'king':
            charachter = 'K'
        elif name == 'pawn':
            charachter = ''
        else:
            charachter = ''
        
        # print(f"{charachter}{chr(97 + x)}{y + 1}")

        return f"{charachter}{chr(97 + x)}{y + 1}"
    def convertChessCordinatesToGrid(self, move_notation):
        
        if len(move_notation) == 2:
            name = 'pawn'
            x = ord(move_notation[0]) - 97
            y = int(move_notation[1]) - 1
        elif len(move_notation) == 3:
            if move_notation[0] == 'R':
                name = 'rook'
            elif move_notation[0] == 'N':
                name = 'knight'
            elif move_notation[0] == 'B':
                name = 'bishop'
            elif move_notation[0] == 'Q':
                name = 'queen'
            elif move_notation[0] == 'K':
                name = 'king'
            x = ord(move_notation[1]) - 97
            y = int(move_notation[2]) - 1

        return name, x, y
    def convertGridCordinatesToTCPCordinates(self, name, x, y, prevX, prevY):
        if name == 'pawn':
            charachter = 'P'
        elif name == 'rook':
            charachter = 'R'
        elif name == 'knight':
            charachter = 'N'
        elif name == 'bishop':
            charachter = 'B'
        elif name == 'queen':
            charachter = 'Q'
        elif name == 'king':
            charachter = 'K'

        text = f"{charachter}{prevX}{prevY}{x}{y}"

        return text
    def convertTCPCordinatesToGridCordinates(self, text):
        if text[0] == 'P':
            name = 'pawn'
        elif text[0] == 'R':
            name = 'rook'
        elif text[0] == 'N':
            name = 'knight'
        elif text[0] == 'B':
            name = 'bishop'
        elif text[0] == 'Q':
            name = 'queen'
        elif text[0] == 'K':
            name = 'king'

        prevX = int(text[1])
        prevY = int(text[2])
        x = int(text[3])
        y = int(text[4])
        print(name, x, y, prevX, prevY)

        return name, x, y, prevX, prevY

    # mechanic methods
    def summarizeSelfMove(self, name, x, y, prevX, prevY, color, hasMoved):
        if self.gameStarted == True:
            #check if the move is possible
            if self.model.canMove(name, prevX, prevY, x, y, color, hasMoved):
                # if true update the board state and move piece

                # if there is enemy piece on the field remove it
                if self.model.currentBoardState[y][x] != 'empty':
                    self.win.removePieceFromBoard(x, y)
                self.movePiece(prevX, prevY, x, y)

                self.model.updateBoardState(name, prevX, prevY, x, y, color)


                text = self.convertGridCordinatesToTCPCordinates(name, x, y, prevX, prevY)
                self.send(text)

                self.updateCurrentPlayerTurn()
                self.win.updateLabelCurrentPlayerTurn(self.currentPlayer)

                self.clk.switchPlayer()

                self.win.scene.update()
                self.botMove()
                return True
            else:
                return False
        else:
            return False
    def summarizeOtherPlayeMove(self, text):
        name, x, y, prevX, prevY = self.convertTCPCordinatesToGridCordinates(text)
        if self.gameStarted == True:
            self.model.updateBoardState(name, prevX, prevY, x, y)
            self.movePiece(prevX, prevY, x, y)

            self.updateCurrentPlayerTurn()
            self.win.updateLabelCurrentPlayerTurn(self.currentPlayer)
            self.win.scene.update()

            self.clk.switchPlayer()
    def summarizeBotMove(self, name, x, y, prevX, prevY, color = 'black', hasMoved = False):
        if self.gameStarted == True:
            
            if self.model.currentBoardState[y][x] != 'empty':
                self.win.removePieceFromBoard(x, y)
            self.movePiece(prevX, prevY, x, y)

            self.model.updateBoardState(name, prevX, prevY, x, y, color)

            self.updateCurrentPlayerTurn()
            self.win.updateLabelCurrentPlayerTurn(self.currentPlayer)
            self.win.scene.update()

            self.clk.switchPlayer()

    def startGame(self, game_mode):
        if game_mode == 'AI bot':
            self.gameStarted = True
            self.humanPlayer = 'white'
            # for now this mode is not available
            pass
        elif game_mode == 'Player same PC':
            self.gameStarted = True
            # ...
        elif game_mode == 'Multiplayer':
            if self.iswho == 'server':
                self.gameStarted = True
                self.send(f'Time{self.time}')
                self.send('gameStarted')
                self.clk.set(self.time)
                self.clk.start()
                self.win.initMainUI()
            elif self.iswho == 'client':
                self.gameStarted = True
                self.clk.set(self.time)
                self.clk.start()
                self.win.initMainUI()

    # AI bot methods
    def botMove(self):
        # check if it is AI bot turn
        
        # get the move from the model
        name, x, y, prevX, prevY  = self.model.findBestMoveForBot()

        # summarize the move
        self.summarizeBotMove(name, x, y, prevX, prevY)
        

    # slots methods
    def startGameSlot(self, game_mode):
        self.startGame(game_mode)

    # updating methods
    def updateMovesHistory(self, move_notation):
        self.moves_history.append(move_notation)
        self.win.updateMoveLog(move_notation)
    def updateSQLbase(self, move_notation):
        # Establish a connection to the database
        conn = sqlite3.connect('chess.db')

        # Create a cursor object to execute SQL queries
        c = conn.cursor()

        # Insert the move notation into the 'moves_history' table
        c.execute('INSERT INTO moves_history VALUES (?)', (move_notation,))

        # Commit changes to the database
        conn.commit()

        # Close the connection when done with all database operations
        conn.close()
    def updateCurrentPlayerTurn(self):
        if self.currentPlayer == 'white':
            self.currentPlayer = 'black'
        else:
            self.currentPlayer = 'white'

    # TCP/IP communication methods
    def createServer(self, port):
        self.connection.createServer(port)
        self.connection.start()
    def joinServer(self, ip, port):
        self.connection.joinServer(ip, port)
        self.connection.start()
        self.send('waiting')
    def send(self, data):
        self.connection.send(data)
    def connectionHandling(self, msg, isWho = None):
        
        if len(msg) == 5 and isWho == None:
            self.summarizeOtherPlayeMove(msg)
        elif len(msg) != 5 and isWho != None:
            if isWho == 'server':
                if msg == 'waiting':
                    self.win.writeTextToLabelConnectionStatus("Connection status: Client connected, waiting for start of the game")
                    self.win.showAcceptButton()
            elif isWho == 'client':
                if msg == 'connectionConfirmed':
                    self.win.writeTextToLabelConnectionStatus("Connection status: Server connected, waiting for host to start the game")
    def reciveMsgFromOtherPlayer(self, msg):
        # odejmij 3 pierwsze litery z stringa msg tak aby pozostała tylko wiadomość
        msg = msg[3:]
        self.win.writeCommunicationWithOtherPlayer(msg)


    # utility methods
    def movePiece(self, prevX, prevY, x, y):
        self.win.movePieceFromInsideProgram(prevX, prevY, x, y)

    # debug methods
    def printMovesHistoryFromWhere(self):
        print(self.moves_history_from_where)
    def createSQLbaseForMovesHistory(self):
        #self.deleteExistingDataBaseDEBBUG()

        # Establish a connection to the database
        conn = sqlite3.connect('chess.db')

        # Create a cursor object to execute SQL queries
        c = conn.cursor()

        # Create the 'moves_history' table if it doesn't exist
        c.execute('''CREATE TABLE IF NOT EXISTS moves_history
                    (move TEXT)''')

        # Commit changes to the database
        conn.commit()

        # **DO NOT CLOSE THE CONNECTION HERE**

        # Use the connection and cursor as needed for subsequent operations
        # ...

        # Close the connection when done with all database operations
        conn.close()
    def deleteExistingDataBaseDEBBUG(self):
        conn = sqlite3.connect('chess.db')
        c = conn.cursor()
        c.execute('DROP TABLE moves_history')
        conn.commit()
        conn.close()
    def saveMovesHistoryToXML(self, moves_history):
        # Create the root element for the XML document
        root = ET.Element("MovesHistory")

        # Iterate through each move in the history and create an XML element for each
        for move in moves_history:
            move_element = ET.Element("Move")
            move_element.text = move
            root.append(move_element)

        # Create an XML file object
        xml_file = open("moves_history.xml", "w")

        # Write the XML tree to the file
        tree = ET.tostring(root, encoding="utf-8")
        xml_file.write(tree.decode("utf-8"))

        # Close the file
        xml_file.close()
    def saveGameInfoToFile(self, game_mode, address, port, filename="game_info.json"):
        # Create a dictionary to store the game information
        game_info = {
            "game_mode": game_mode,
            "address": address,
            "port": port
        }

        # Open the JSON file in write mode ("w")
        with open(filename, "w") as json_file:
            # Convert the dictionary to JSON format and write it to the file
            json.dump(game_info, json_file, indent=4)
    def loadGameInfoFromFile(self, filename="game_info.json"):
        # Attempt to open the JSON file in read mode ("r")
        try:
            with open(filename, "r") as json_file:
                # Load the JSON data from the file
                game_info = json.load(json_file)

            # Extract and return the game mode, address, and port
            game_mode = game_info["game_mode"]
            address = game_info["address"]
            port = game_info["port"]

            return game_mode, address, port

        # Handle exceptions if the file cannot be opened or read
        except (FileNotFoundError, json.JSONDecodeError):
            print(f"Error loading game info from file: {filename}")
            return None, None, None
    def playHistoryOnScreen(self):
        while len(self.moves_history) > 0:
            name, newx, newy = self.convertChessCordinatesToGrid(self.moves_history.pop(0))
            name, prevX, prevY = self.convertChessCordinatesToGrid(self.moves_history_from_where.pop(0))
            print(self.moves_history_from_where)
            print(self.moves_history)
            print(f"Moving {name} from {prevX}, {prevY} to {newx}, {newy}")
            self.win.movePieceFromInsideProgram(prevX, prevY, newx, newy)

            time.sleep(1)



class ChessPiece(QGraphicsSvgItem):
    def __init__(self, svg_path, x, y, color, name, win):
        super().__init__(svg_path)
        self.win = win
        self.Name = name
        self.defaultScale = 1.8
        self.color = color
        self.oposite_color = self.color == 'white' and 'black' or 'white'
        self.hasMoved = False
        self.PrevX = x
        self.PrevY = y
        self.svg_path = svg_path

        self.setPos(x, y)
        self.setScale(self.defaultScale)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemIsSelectable)

    def pos(self):
        return self.x, self.y
    
    def getPreviousPosition(self):
        return round(self.PrevX // 80), round(self.PrevY // 80)

    def mouseReleaseEvent(self, event: QGraphicsSceneMouseEvent) -> None:
        self.setScale(self.defaultScale)

        newx, newy = self.convertNumericalToGridCordinates(self.x(), self.y())
        PrevX, PrevY = self.convertNumericalToGridCordinates(self.PrevX, self.PrevY)
        # if not self.win.presenter.summarizeSelfMove(self.Name, newx, newy, PrevX, PrevY, self.color, self.hasMoved) == True:
        #     self.setPos(self.PrevX, self.PrevY)
        if self.win.presenter.model.canMove(self.Name, PrevX, PrevY, newx, newy, self.color, self.hasMoved) == True:
            # print(self.win.presenter.model.canMove(self.Name, PrevX, PrevY, newx, newy, self.color, self.hasMoved))

            debbug = self.win.presenter.summarizeSelfMove(self.Name, newx, newy, PrevX, PrevY, self.color, self.hasMoved)
            # print(f'before {self.Name} from {PrevX}, {PrevY} to {newx}, {newy}. Has moved: {self.hasMoved}')
            self.PrevX = newx * 80
            self.PrevY = newy * 80
            self.hasMoved = True
            # print(f'after {self.Name}, prevX self {self.PrevX},  prevY self {self.PrevY} to {newx}, {newy}. Has moved: {self.hasMoved}')
        else:
            self.setPos(self.PrevX, self.PrevY)
        
        super().mouseReleaseEvent(event)

    def mousePressEvent(self, event: QGraphicsSceneMouseEvent) -> None:
        self.PrevX = self.x()
        self.PrevY = self.y()
        self.setScale(self.defaultScale + 0.2)
        self.win.scene.update()
        super().mousePressEvent(event)

    def convertNumericalToGridCordinates(self, x, y):
        return round(x / 80), round(y / 80)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    Presenter = Presenter()
    sys.exit(app.exec_())