import sys
from PyQt5.QtWidgets import QApplication, QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsItem
from PyQt5.QtSvg import QGraphicsSvgItem
from PyQt5.QtGui import QBrush, QColor, QTransform
from PyQt5.QtCore import Qt, QPointF

class ChessBoard(QGraphicsView):
    def __init__(self):
        super(ChessBoard, self).__init__()
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setSceneRect(0, 0, 640, 640)
        self.drawBoard()
        self.addPieces()
        self.current_turn = 'white'  # White starts the game
        self.current_board_state = [[0 for _ in range(8)] for _ in range(8)]
        self.turnTimer = 0
        self.setStartingboardState()

    # Method to switch turns
    def switchTurns(self):
        self.current_turn = 'black' if self.current_turn == 'white' else 'white'


    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)

    def addPieces(self):
        # Black pieces
        self.addPiece(Rook("pieces/black/brook.svg", 0, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 1, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 2, 0, 'black',self))
        self.addPiece(Queen("pieces/black/bqueen.svg", 3, 0, 'black',self))
        self.addPiece(King("pieces/black/bking.svg", 4, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 5, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 6, 0, 'black',self))
        self.addPiece(Rook("pieces/black/brook.svg", 7, 0, 'black',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/black/bpawn.svg", i, 1, 'black', self))
        
        # White pieces
        self.addPiece(Rook("pieces/white/wrook.svg", 0, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 1, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 2, 7, 'white',self))
        self.addPiece(Queen("pieces/white/wqueen.svg", 3, 7, 'white',self))
        self.addPiece(King("pieces/white/wking.svg", 4, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 5, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 6, 7, 'white',self))
        self.addPiece(Rook("pieces/white/wrook.svg", 7, 7, 'white',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/white/wpawn.svg", i, 6, 'white', self))

    def addPiece(self, piece):
        self.scene.addItem(piece)

    def setStartingboardState(self):

        # Empty spaces
        for i in range(2, 6):
            for j in range(8):
                self.current_board_state[i][j] = "Empty"

        for i in range(8):
            for j in range(2):
                if i == 0 and j == 4:
                    self.current_board_state[j][i] = "black_king"
                else:
                    self.current_board_state[j][i] = "black_piece"

        for i in range(8):
            for j in range(6, 8):
                if i == 7 and j == 4:
                    self.current_board_state[j][i] = "white_king"
                else:
                    self.current_board_state[j][i] = "white_piece"

    def getBoardState(self):
        return self.current_board_state

    

class ChessPiece(QGraphicsSvgItem):
    def __init__(self, image_path, x, y, color, chessboard):
        super(ChessPiece, self).__init__(image_path)
        self.setPos(x * 80, y * 80)
        self.default_scale = 1.8
        self.setScale(self.default_scale)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemIsSelectable)
        self.color = color
        self.chessboard = chessboard
        self.isKing = False
        self.valid_move = False
        self.direction = 1 if self.color == 'black' else -1
        self.oposite_color = 'white' if self.color == 'black' else 'black'

    def mousePressEvent(self, event):
        super(ChessPiece, self).mousePressEvent(event)

        # Store the current grid position when the mouse is pressed
        self.original_grid_x = int(self.x() / 80)
        self.original_grid_y = int(self.y() / 80)

    def validate_move(self):

        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        # Check bounds
        if not (0 <= new_grid_x <= 7 and 0 <= new_grid_y <= 7):
            self.return_to_original_position()
            return

        # checing condition if there is figure on the new position [exlcuding the case of pawn]
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":

            # cant move if there is friendly piece on the new position
            if self.color == 'black':
                if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_piece":
                    self.return_to_original_position()
                    return
                else:
                    self.valid_move = True
            elif self.color == 'white':
                if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_piece":
                    self.return_to_original_position()
                    return
                else:
                    self.valid_move = True

            # cannot move if there is a king piece in the new position
            if self.chessboard.current_board_state[new_grid_y][new_grid_x] == "black_king" or self.chessboard.current_board_state[new_grid_y][new_grid_x] == "white_king":
                self.return_to_original_position()
                return

        # if the piece is not the color of the current turn, it cannot move
        if self.color != self.chessboard.current_turn:
            self.return_to_original_position()
            return


        # updating the board state and moving the piece if the move is valid
        if self.valid_move == True:
            self.cupture_piece()
            self.setPos(new_x, new_y)
            self.updateBoardStatus()
            self.chessboard.switchTurns()
            self.first_move = False

    def cupture_piece(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()

        # remove piece that is being taken by player
        for item in self.scene().items():
            if isinstance(item, ChessPiece) and item.x() == new_x and item.y() == new_y:
                self.scene().removeItem(item)
                break

    def return_to_original_position(self):
        self.setPos(self.original_grid_x * 80, self.original_grid_y * 80)

    def mouseReleaseEvent(self, event):
        super(ChessPiece, self).mouseReleaseEvent(event)

        self.validate_move()

        self.setScale(self.default_scale)
        
        # Remove any existing move indicators from the scene
        for item in self.scene().items():
            if isinstance(item, QGraphicsRectItem) and item.brush().color() == QColor(0, 255, 0, 127):
                self.scene().removeItem(item)

    def updateBoardStatus(self):

        # prevoius move of the piece
        prev_x = round(self.original_grid_x * 80)
        prev_y = round(self.original_grid_y * 80)

        prev_grid_x = int(prev_x / 80)
        prev_grid_y = int(prev_y / 80)

        self.chessboard.current_board_state[prev_grid_y][prev_grid_x] = "Empty"

        # current move of the piece
        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)

        if self.color == 'black':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "black_piece"
        elif self.color == 'white':
            if self.isKing:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_king"
            else:
                self.chessboard.current_board_state[new_grid_y][new_grid_x] = "white_piece"

        # self.printCurrentBoardStateInTerminal()

    def calculate_position(self):

        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)


        return new_x, new_y, new_grid_x, new_grid_y
    
    def printCurrentBoardStateInTerminal(self):
        for row in self.chessboard.current_board_state:
            print(row)
        print('\n')

    def getPreviousGridPosition(self):
        return self.original_grid_x, self.original_grid_y   



class Pawn(ChessPiece, QGraphicsSvgItem):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Pawn, self).__init__(image_path, x, y, color, chessboard)  # Corrected parameter passing
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def validate_move(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # pawn can move one square forward
        if self.color == "white" and new_grid_y == original_grid_y - 1 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
            self.valid_move = True
        elif self.color == "black" and new_grid_y == original_grid_y + 1 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
            self.valid_move = True
        # pawn can move two squares forward on its first move
        elif self.first_move and self.color == "white" and new_grid_y == original_grid_y - 2 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y + 1][new_grid_x] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
            self.valid_move = True
        elif self.first_move and self.color == "black" and new_grid_y == original_grid_y + 2 and new_grid_x == original_grid_x and self.chessboard.current_board_state[new_grid_y - 1][new_grid_x] == "Empty" and self.chessboard.current_board_state[new_grid_y][new_grid_x] == "Empty":
            self.valid_move = True
        # pawn can only move diagonally when capturing an opponent's piece
        elif abs(new_grid_x - original_grid_x) == 1 and ((self.color == "white" and new_grid_y == original_grid_y - 1) or (self.color == "black" and new_grid_y == original_grid_y + 1)) and self.chessboard.current_board_state[new_grid_y][new_grid_x] != "Empty":
            self.valid_move = True
        else:
            self.return_to_original_position()
            return

        if self.valid_move:
            self.first_move = False


        super(Pawn, self).validate_move()
    
class Rook(ChessPiece):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Rook, self).__init__(image_path, x, y, color, chessboard)
        self.color = color
        self.first_move = True
        self.chessboard = chessboard
    
    def validate_move(self):

        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()



        # rook canot jump above the figures, so if there is a figure in the way of the rook, it cannot move further
        if new_grid_x == original_grid_x:
            if new_grid_y > original_grid_y:
                for i in range(original_grid_y + 1, new_grid_y):
                    if self.chessboard.current_board_state[i][new_grid_x] != "Empty":
                        print("Invalid move 1")
                        self.return_to_original_position()
                        return
            else:
                for i in range(new_grid_y + 1, original_grid_y):
                    if self.chessboard.current_board_state[i][new_grid_x] != "Empty":
                        print("Invalid move 1")
                        self.return_to_original_position()
                        return
        elif new_grid_y == original_grid_y:
            if new_grid_x > original_grid_x:
                for i in range(original_grid_x + 1, new_grid_x):
                    if self.chessboard.current_board_state[new_grid_y][i] != "Empty":
                        print("Invalid move 1")
                        self.return_to_original_position()
                        return
            else:
                for i in range(new_grid_x + 1, original_grid_x):
                    if self.chessboard.current_board_state[new_grid_y][i] != "Empty":
                        print("Invalid move 1")
                        self.return_to_original_position()
                        return

        # rook cannot move on other than vertical or horizontal direction
        if new_grid_x != original_grid_x and new_grid_y != original_grid_y:
            print("Invalid move 1")
            self.return_to_original_position()
            return
        else:
            self.valid_move = True


        # if there is a friendly figure in the way of the rook or enemy king, it cannot move on this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            print("Invalid move 2")
            self.return_to_original_position()
            return
        else:
            self.valid_move = True

        super(Rook, self).validate_move()

        # super(Rook, self).mouseReleaseEvent(event)

class Knight(ChessPiece):
    def validate_move(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # knight can move in L shape, so it can move to 8 different positions
        if abs(new_grid_x - original_grid_x) == 2 and abs(new_grid_y - original_grid_y) == 1:
            self.valid_move = True
        elif abs(new_grid_x - original_grid_x) == 1 and abs(new_grid_y - original_grid_y) == 2:
            self.valid_move = True
        else:
            self.return_to_original_position()
            return

        # if there is a friendly figure in the way of the knight or enemy king, it cannot move on this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            self.return_to_original_position()
            return
        else:
            self.valid_move = True

        super(Knight, self).validate_move()

class Bishop(ChessPiece):
    def validate_move(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # bishop can move diagonally, so the difference between the x and y coordinates should be the same
        if abs(new_grid_x - original_grid_x) != abs(new_grid_y - original_grid_y):
            self.return_to_original_position()
            return
        else:
            # check if there is a piece in the way of the bishop
            x_direction = 1 if new_grid_x > original_grid_x else -1
            y_direction = 1 if new_grid_y > original_grid_y else -1
            x, y = original_grid_x + x_direction, original_grid_y + y_direction
            while x != new_grid_x and y != new_grid_y:
                if self.chessboard.current_board_state[y][x] != "Empty":
                    self.return_to_original_position()
                    return
                x += x_direction
                y += y_direction

        # if there is a friendly figure or enemy king on the destination square, the bishop cannot move to this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            self.return_to_original_position()
            return
        else:
            self.valid_move = True

        super(Bishop, self).validate_move()

class Queen(ChessPiece):

    def validate_move(self):
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # queen can move horizontally, vertically, or diagonally
        if new_grid_x != original_grid_x and new_grid_y != original_grid_y and abs(new_grid_x - original_grid_x) != abs(new_grid_y - original_grid_y):
            self.return_to_original_position()
            return

        # check if there is a piece in the way of the queen
        x_direction = 0 if new_grid_x == original_grid_x else 1 if new_grid_x > original_grid_x else -1
        y_direction = 0 if new_grid_y == original_grid_y else 1 if new_grid_y > original_grid_y else -1
        x, y = original_grid_x + x_direction, original_grid_y + y_direction
        while x != new_grid_x or y != new_grid_y:
            if self.chessboard.current_board_state[y][x] != "Empty":
                self.return_to_original_position()
                return
            x += x_direction
            y += y_direction

        # if there is a friendly figure or enemy king on the destination square, the queen cannot move to this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            self.return_to_original_position()
            return
        else:
            self.valid_move = True 

        super(Queen, self).validate_move()

class King(ChessPiece):
    def validate_move(self):
        
        new_x, new_y, new_grid_x, new_grid_y = self.calculate_position()
        original_grid_x, original_grid_y = self.getPreviousGridPosition()

        # king can move one square in any direction
        if abs(new_grid_x - original_grid_x) > 1 or abs(new_grid_y - original_grid_y) > 1:
            self.return_to_original_position()
            return

        # if there is a friendly figure or enemy king on the destination square, the king cannot move to this position
        if self.chessboard.current_board_state[new_grid_y][new_grid_x] in ["black_king", "white_king", self.color + "_piece"]:
            self.return_to_original_position()
            return
        else:
            self.valid_move = True
        
        super(King, self).validate_move()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    board = ChessBoard()
    board.show()
    sys.exit(app.exec_())
