import sys
from PyQt5.QtWidgets import QApplication, QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsItem
from PyQt5.QtSvg import QGraphicsSvgItem
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtCore import Qt, QPointF

class ChessBoard(QGraphicsView):
    def __init__(self):
        super(ChessBoard, self).__init__()
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setSceneRect(0, 0, 640, 640)
        self.drawBoard()
        self.addPieces()
        self.current_turn = 'white'  # White starts the game
        self.current_board_state = [[0 for _ in range(8)] for _ in range(8)]
        self.turnTimer = 0
        self.setStartingboardState()

    # Method to switch turns
    def switchTurns(self):
        self.current_turn = 'black' if self.current_turn == 'white' else 'white'


    def drawBoard(self):
        light_color = QColor(173, 216, 230)  # Light blue
        dark_color = QColor(0, 0, 139)       # Dark blue
        for i in range(8):
            for j in range(8):
                rect = QGraphicsRectItem(80 * j, 80 * i, 80, 80)
                rect.setBrush(QBrush(light_color if (i + j) % 2 == 0 else dark_color))
                self.scene.addItem(rect)

    def addPieces(self):
        # Black pieces
        self.addPiece(Rook("pieces/black/brook.svg", 0, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 1, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 2, 0, 'black',self))
        self.addPiece(Queen("pieces/black/bqueen.svg", 3, 0, 'black',self))
        self.addPiece(King("pieces/black/bking.svg", 4, 0, 'black',self))
        self.addPiece(Bishop("pieces/black/bbishop.svg", 5, 0, 'black',self))
        self.addPiece(Knight("pieces/black/bknight.svg", 6, 0, 'black',self))
        self.addPiece(Rook("pieces/black/brook.svg", 7, 0, 'black',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/black/bpawn.svg", i, 1, 'black', self))
        
        # White pieces
        self.addPiece(Rook("pieces/white/wrook.svg", 0, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 1, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 2, 7, 'white',self))
        self.addPiece(Queen("pieces/white/wqueen.svg", 3, 7, 'white',self))
        self.addPiece(King("pieces/white/wking.svg", 4, 7, 'white',self))
        self.addPiece(Bishop("pieces/white/wbishop.svg", 5, 7, 'white',self))
        self.addPiece(Knight("pieces/white/wknight.svg", 6, 7, 'white',self))
        self.addPiece(Rook("pieces/white/wrook.svg", 7, 7, 'white',self))
        for i in range(8):
            self.addPiece(Pawn("pieces/white/wpawn.svg", i, 6, 'white', self))

    def addPiece(self, piece):
        self.scene.addItem(piece)

    def setStartingboardState(self):
        if self.turnTimer == 0:
            self.turnTimer = 1
            for i in range(8):
                for j in range(8):
                    self.current_board_state[i][j] = 0

            for item in self.scene.items():
                if isinstance(item, ChessPiece):
                    x = int(item.x() / 80)
                    y = int(item.y() / 80)
                    self.current_board_state[y][x] = 1

            for item in self.scene.items():
                if isinstance(item, King):
                    x = int(item.x() / 80)
                    y = int(item.y() / 80)
                    self.current_board_state[y][x] = 2  

    def getBoardState(self):
        return self.current_board_state

    

class ChessPiece(QGraphicsSvgItem):
    def __init__(self, image_path, x, y, color, chessboard):
        super(ChessPiece, self).__init__(image_path)
        self.setPos(x * 80, y * 80)
        self.default_scale = 1.8
        self.setScale(self.default_scale)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemIsSelectable)
        self.color = color
        self.chessboard = chessboard
        self.isKing = False

    def updateBoardStatus(self):
        # prevoius move of the piece
        prev_x = round(self.original_grid_x * 80)
        prev_y = round(self.original_grid_y * 80)

        prev_grid_x = int(prev_x / 80)
        prev_grid_y = int(prev_y / 80)

        self.chessboard.current_board_state[prev_grid_y][prev_grid_x] = 0

        # current move of the piece
        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)

        if self.isKing:
            self.chessboard.current_board_state[new_grid_y][new_grid_x] = 2
        else:
            self.chessboard.current_board_state[new_grid_y][new_grid_x] = 1

        self.printCurrentBoardStateInTerminal()

        
    def printCurrentBoardStateInTerminal(self):
        for row in self.chessboard.current_board_state:
            print(row)
        print('\n')





class Pawn(ChessPiece, QGraphicsSvgItem):
    def __init__(self, image_path, x, y, color, chessboard):
        super(Pawn, self).__init__(image_path, x, y, color, chessboard)  # Corrected parameter passing
        self.color = color
        self.first_move = True
        self.chessboard = chessboard

    def mousePressEvent(self, event):
        super(Pawn, self).mousePressEvent(event)  # Ensure the default behavior runs
        
        # Store the current grid position when the mouse is pressed
        self.original_grid_x = int(self.x() / 80)
        self.original_grid_y = int(self.y() / 80)

        # Remove any existing move indicators from the scene
        for item in self.scene().items():
            if isinstance(item, QGraphicsRectItem) and item.brush().color() == QColor(0, 255, 0, 127):
                self.scene().removeItem(item)

        # Show possible moves
        move_1 = 1 if self.color == 'black' else -1
        rect1 = QGraphicsRectItem(80 * self.x() / 80, 80 * (self.y() / 80 + move_1), 80, 80)
        rect1.setBrush(QBrush(QColor(0, 255, 0, 127)))
        self.scene().addItem(rect1)

        # Show second move if it's the first move of the pawn
        if self.first_move:
            move_2 = 2 if self.color == 'black' else -2
            rect2 = QGraphicsRectItem(80 * self.x() / 80, 80 * (self.y() / 80 + move_2), 80, 80)
            rect2.setBrush(QBrush(QColor(0, 255, 0, 127)))
            self.scene().addItem(rect2)

    def mouseReleaseEvent(self, event):
        # Calculate new position
        new_x = round(self.pos().x() / 80) * 80
        new_y = round(self.pos().y() / 80) * 80

        new_grid_x = int(new_x / 80)
        new_grid_y = int(new_y / 80)

        direction = 1 if self.color == 'black' else -1
        valid_move = False

        # Validate move
        if self.chessboard.current_turn == self.color:
            if new_grid_x == self.original_grid_x:
                if self.first_move and new_grid_y - self.original_grid_y == 2 * direction:
                    valid_move = True
                elif new_grid_y - self.original_grid_y == direction:
                    valid_move = True
        else:
            valid_move = False

        # Check bounds
        if not (0 <= new_grid_x <= 7 and 0 <= new_grid_y <= 7):
            valid_move = False

        # Update or revert position
        if not valid_move:
            self.setPos(self.original_grid_x * 80, self.original_grid_y * 80)
        else:
            self.setPos(new_x, new_y)
            self.first_move = False
            self.updateBoardStatus()
            if self.chessboard.current_turn == 'black':
                self.chessboard.current_turn = 'white'
            else:
                self.chessboard.current_turn = 'black'
        ##board_state = self.board.board_state
        ##board_state[self.original_grid_y][self.original_grid_x] = False
                
        # Remove any existing move indicators from the scene
        for item in self.scene().items():
            if isinstance(item, QGraphicsRectItem) and item.brush().color() == QColor(0, 255, 0, 127):
                self.scene().removeItem(item)

        self.setScale(self.default_scale)
        super(Pawn, self).mouseReleaseEvent(event)
    


class Rook(ChessPiece):
    def __init__(self, image_path, x, y, color, board):
        super(Rook, self).__init__(image_path, x, y, color, board)

    def mousePressEvent(self, event):
        # Logic for showing possible moves for a rook can be added here
        
        #show posible moves of rook in 4 directions with if statemanet that rect wont be painted outside of chessboard

        move_1 = 1
        rect1 = QGraphicsRectItem(80 * self.x() / 80, 80 * (self.y() / 80 + move_1), 80, 80)
        rect1.setBrush(QBrush(QColor(0, 255, 0, 127)))
        self.scene().addItem(rect1)
        
        
        self.setScale(self.default_scale * 1.1)
        super(Rook, self).mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        # You might add more complex move validation logic here later
        self.setScale(self.default_scale)
        super(Rook, self).mouseReleaseEvent(event)

class Knight(ChessPiece):
    def mouseReleaseEvent(self, event):
        # Knight logic: L-shaped moves
        x_diff = abs(self.x() - event.lastPos().x())
        y_diff = abs(self.y() - event.lastPos().y())
        if not ((x_diff == 160 and y_diff == 80) or (x_diff == 80 and y_diff == 160)):
            self.setPos(event.lastPos())
        else:
            self.setPos(round(self.x() / 80) * 80, round(self.y() / 80) * 80)
        super(Knight, self).mouseReleaseEvent(event)

class Bishop(ChessPiece):
    def mouseReleaseEvent(self, event):
        # Bishop logic: can move diagonally
        if abs(self.x() - event.lastPos().x()) != abs(self.y() - event.lastPos().y()):
            self.setPos(event.lastPos())
        else:
            self.setPos(round(self.x() / 80) * 80, round(self.y() / 80) * 80)
        super(Bishop, self).mouseReleaseEvent(event)

class Queen(ChessPiece):
    def mouseReleaseEvent(self, event):
        # Queen logic: combines rook and bishop
        if self.x() != event.lastPos().x() and self.y() != event.lastPos().y() and \
           abs(self.x() - event.lastPos().x()) != abs(self.y() - event.lastPos().y()):
            self.setPos(event.lastPos())
        else:
            self.setPos(round(self.x() / 80) * 80, round(self.y() / 80) * 80)
        super(Queen, self).mouseReleaseEvent(event)

class King(ChessPiece):
    def __init__(self, image_path, x, y, color, board):
        super(King, self).__init__(image_path, x, y, color, board)
        self.isKing = True

    def mouseReleaseEvent(self, event):
        # King logic: one square any direction
        if abs(self.x() - event.lastPos().x()) > 80 or abs(self.y() - event.lastPos().y()) > 80:
            self.setPos(event.lastPos())
        else:
            self.setPos(round(self.x() / 80) * 80, round(self.y() / 80) * 80)
        super(King, self).mouseReleaseEvent(event)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    board = ChessBoard()
    board.show()
    sys.exit(app.exec_())
